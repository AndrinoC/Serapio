<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seraph Defesa Final</title>
    <link rel="icon" type="image/png" href="img/icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        background-color: #000;
        color: #fff;
        font-family: "Press Start 2P", Courier, monospace;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        background-color: #000;
        display: block;
      }
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 50;
        text-align: center;
        overflow-y: auto;
        padding: 20px 0;
      }
      #splashScreen {
        background-color: #000;
        z-index: 100;
      }
      .splash-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .splash-options-row {
        display: flex;
        gap: 20px;
        margin-top: 0;
      }
    .run-summary {
        font-size: 1.1em;
        line-height: 1.8;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border: 1px solid #f1c40f;
        margin-bottom: 30px;
        text-align: left;
        max-width: 600px;
      }
      .run-summary h3 {
        color: #00ffff;
        margin-top: 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #00ffff;
        padding-bottom: 5px;
      }
      #wikiScreen {
        display: none;
        flex-direction: column;
      }
      #wikiSearchBox {
        width: 80%;
        max-width: 600px;
        padding: 10px;
        margin-bottom: 20px;
        background-color: #111;
        border: 2px solid #555;
        color: #fff;
        font-family: "Press Start 2P", Courier, monospace;
        font-size: 0.8em;
      }
      .wiki-list {
        width: 90%;
        max-width: 800px;
        max-height: 70vh;
        overflow-y: auto;
        border: 2px solid #555;
        padding: 15px;
        background: rgba(0,0,0,0.5);
        margin-bottom: 20px;
      }
      .wiki-item {
        padding: 15px;
        border-bottom: 1px dotted #444;
      }
      .wiki-item:last-child {
        border-bottom: none;
      }
      .wiki-item h3 {
        margin: 0 0 5px 0;
        font-size: 1.2em;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .wiki-item p {
        margin: 0 0 10px 0;
        color: #ccc;
        font-family: "Courier New", Courier, monospace;
      }
      .wiki-item .rarity {
        font-size: 0.8em;
        font-weight: bold;
        text-transform: uppercase;
      }
      #dev-controls {
        display: flex;
        gap: 10px;
        margin-top: 0;
      }
      #splashScreen h1 {
        margin-bottom: 50px;
      }
      .splash-divider {
        width: 80%;
        max-width: 500px;
        border: 0;
        height: 1px;
        background-image: linear-gradient(
          to right,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0.2),
          rgba(255, 255, 255, 0)
        );
        margin: 25px 0 15px;
      }
      .splash-section-title {
        font-size: 1em;
        color: #ccc;
        margin: 0 0 10px;
        font-weight: 400;
      }
      #dev-controls .btn {
        font-size: 0.7em;
        padding: 8px 12px;
      }
      #resetProgressButton {
        border-color: #c0392b;
        color: #c0392b;
      }
      #splashScreen h1,
      #gameOverTitle,
      #pauseTitle {
        font-size: 4em;
        text-shadow: 2px 2px 10px #ff00ff;
        margin-bottom: 20px;
        line-height: 1.2;
      }
      #splashScreen p {
        font-size: 1em;
        margin-bottom: 40px;
        color: #ccc;
        line-height: 1.5;
      }
      .btn,
      #splashScreen button,
      #restartButton,
      #resumeButton,
      #restartFromPauseButton {
        padding: 15px 30px;
        font-size: 1.2em;
        cursor: pointer;
        background-color: #000;
        color: #fff;
        border: 2px solid #fff;
        transition: background-color 0.2s, color 0.2s;
        margin: 10px;
        font-family: "Press Start 2P", Courier, monospace;
      }
      .btn:hover,
      #splashScreen button:hover,
      #restartButton:hover,
      #resumeButton:hover,
      #restartFromPauseButton:hover {
        background-color: #fff;
        color: #000;
      }
      #top-ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 10;
      }
      #exp-bar-container {
        width: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 0;
        box-shadow: none;
        margin: 0;
      }
      #left-ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        text-shadow: 1px 1px 3px #000;
      }
      #game-info-text {
        font-size: 1.5em;
        color: #fff;
        margin-bottom: 10px;
      }
      #score-text {
        font-size: 1.2em;
        color: #f1c40f;
      }
      #timer-text {
        font-size: 1.2em;
        color: #fff;
        margin-top: 5px;
      }
      #soul-popup {
        position: absolute;
        bottom: 10px;
        left: 20px;
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.3);
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #add8e6;
        color: #add8e6;
        font-size: 1.1em;
        font-weight: 700;
        text-shadow: 1px 1px 3px #000;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }
      #soul-popup.active {
        opacity: 1;
      }
      .bar-container {
        width: 100%;
        background-color: rgba(0, 0, 0, 0.2);
        margin-bottom: 10px;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.4);
      }
      @keyframes shimmer {
        0% {
          background-position: -100% 0;
        }
        100% {
          background-position: 100% 0;
        }
      }
      @keyframes liquid-flow {
        0% {
          background-position: -200% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }
      .bar {
        height: 10px;
        transition: width 0.5s ease-out;
        position: relative;
        overflow: hidden;
      }
      .bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0) 0,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0) 100%
        );
        background-size: 200% 100%;
        animation: shimmer 2s linear infinite;
      }
      #exp-bar {
        background-color: #2ecc71;
        box-shadow: 0 0 5px #2ecc71, inset 0 0 5px rgba(255, 255, 255, 0.2);
        background-image: linear-gradient(
          90deg,
          transparent 25%,
          rgba(255, 255, 255, 0.2) 50%,
          transparent 75%,
          transparent 100%
        );
        background-size: 200% 100%;
        animation: liquid-flow 3s linear infinite;
      }
      @keyframes background-pan {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 400% 400%;
        }
      }
      @keyframes flash-effect {
        0%,
        100% {
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }
      #levelUpFlash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at center,
          rgba(255, 255, 220, 0.8) 0,
          rgba(255, 255, 220, 0) 70%
        );
        opacity: 0;
        pointer-events: none;
        z-index: 999;
      }
      #levelUpFlash.active {
        animation: flash-effect 0.8s ease-out;
      }
      #levelUpScreen,
      #gameOverScreen,
      #pauseScreen,
      #splashHatShopScreen,
      #leaderboardScreen {
        display: none;
      }
      #levelUpScreen {
        background-color: #01011a;
        background-image: radial-gradient(
            ellipse at 50% 100%,
            rgba(66, 134, 244, 0.4) 0,
            transparent 60%
          ),
          radial-gradient(
            ellipse at 80% 0,
            rgba(0, 255, 255, 0.3) 0,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 20% 0,
            rgba(155, 89, 182, 0.3) 0,
            transparent 50%
          );
        background-size: 400% 400%;
        animation: background-pan 45s linear infinite;
      }
      #levelUpTitle {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-shadow: 2px 2px 8px #00ffff;
      }
      #pauseTitle {
        color: #00ffff;
        text-shadow: 2px 2px 10px #00ffff;
      }
      #upgradeCardsContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 25px;
        margin-bottom: 30px;
      }
      .upgrade-card {
        width: 220px;
        min-height: 280px;
        border: 2px solid;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        background: radial-gradient(ellipse at top, #3a3a3a, #111);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: center;
      }
      .upgrade-card:hover {
        transform: translateY(-10px) scale(1.05);
      }
      .card-icon {
        width: 100%;
        height: 80px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 15px;
      }
      .card-icon img {
        width: 64px;
        height: 64px;
        image-rendering: pixelated;
      }
      .card-header {
        padding: 10px 15px 15px 15px;
      }
      .card-header h3 {
        margin: 0;
        font-size: 1em;
        color: #fff;
        line-height: 1.4;
      }
      .card-rarity {
        font-size: 0.8em;
        font-weight: 700;
        margin-top: 5px;
        text-transform: uppercase;
        opacity: 0.8;
      }
      .card-divider {
        height: 1px;
        background: linear-gradient(
          to right,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        margin: 0 15px;
      }
      .card-description {
        padding: 20px 15px;
        font-size: 0.8em;
        color: #ddd;
        flex-grow: 1;
        line-height: 1.6;
        font-family: "Courier New", Courier, monospace;
      }
      .rarity-common {
        border-color: #fff;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
      }
      .rarity-common .card-rarity {
        color: #fff;
      }
      .rarity-common:hover {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      }
      .rarity-uncommon {
        border-color: #3498db;
        box-shadow: 0 0 8px rgba(52, 152, 219, 0.7);
      }
      .rarity-uncommon .card-rarity {
        color: #3498db;
      }
      .rarity-uncommon:hover {
        box-shadow: 0 0 20px rgba(52, 152, 219, 1);
      }
      .rarity-rare {
        border-color: #9b59b6;
        box-shadow: 0 0 8px rgba(155, 89, 182, 0.7);
      }
      .rarity-rare .card-rarity {
        color: #9b59b6;
      }
      .rarity-rare:hover {
        box-shadow: 0 0 20px rgba(155, 89, 182, 1);
      }
      #rerollButton {
        padding: 10px 20px;
        font-size: 1.2em;
        cursor: pointer;
        background-color: #000;
        color: #00ffff;
        border: 2px solid #00ffff;
        box-shadow: 0 0 10px #00ffff;
      }
      #rerollButton:disabled {
        color: #555;
        border-color: #555;
        box-shadow: none;
        cursor: not-allowed;
      }
      #waveAnnouncer {
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 4em;
        color: #fff;
        text-shadow: 2px 2px 10px #ff00ff;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      #gameOverTitle {
        color: #c0392b;
        text-shadow: 4px 4px 0 #5c110a;
      }
      #gameOverStats {
        margin-bottom: 20px;
        font-size: 1.2em;
        line-height: 1.6;
      }
      .hat-shop-wrapper {
        margin-top: 20px;
        border-top: 2px solid #555;
        padding-top: 20px;
        width: 80%;
      }
      .hat-shop-wrapper h2 {
        margin-top: 0;
      }
      .hat-shop-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        max-height: 200px;
        overflow-y: auto;
        padding: 0 20px;
      }
      .hat-card {
        background: #222;
        border: 1px solid #444;
        padding: 10px;
        width: 150px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }
      .hat-card canvas {
        background-color: #000;
        border: 1px solid #333;
      }
      .hat-card button {
        width: 100%;
        padding: 5px;
        margin-top: 5px;
        cursor: pointer;
        border: 1px solid #888;
        background-color: #333;
        color: #fff;
      }
      .hat-card button:disabled {
        background: #555;
        color: #888;
        cursor: not-allowed;
      }
      .hat-card button.equipped {
        background: #2ecc71;
        border-color: #27ae60;
        color: #fff;
      }
      .splash-buttons {
        display: flex;
        gap: 20px;
      }
      .splash-options-row .btn {
        font-size: 1em;
        padding: 10px 20px;
      }
      .pause-options-row {
        position: absolute;
        bottom: 15%;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      .pause-options-row .btn {
        margin: 0;
        font-size: 1em;
        padding: 10px 20px;
      }
      #leaderboard {
        background: rgba(0, 0, 0, 0.85);
        border-top: 2px solid #555;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-top: 20px;
      }
      #leaderboard h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboard-list {
        list-style: none;
        padding: 0;
        max-height: 180px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboard-list li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboard-list li span:last-child {
        color: #f1c40f;
      }
      #leaderboard-list li:last-child {
        border: none;
      }
      #score-submission input {
        background: #111;
        border: 1px solid #888;
        color: #fff;
        padding: 8px;
        margin-right: 10px;
        font-family: "Press Start 2P", Courier, monospace;
      }
      #score-submission button {
        padding: 8px 15px;
        font-size: 1em;
      }
      #submission-message {
        margin-top: 10px;
        font-size: 0.9em;
      }
      #submission-message.error {
        color: #e74c3c;
      }
      #leaderboardScreen .leaderboard-container {
        background: rgba(0, 0, 0, 0.85);
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-bottom: 20px;
      }
      #leaderboardScreen h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboardScreen ul {
        list-style: none;
        padding: 0;
        max-height: 300px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboardScreen li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboardScreen li:last-child {
        border: none;
      }
      #leaderboardScreen li span:last-child {
        color: #f1c40f;
      }
      #leaderboardScreen .leaderboard-container {
        background: rgba(0, 0, 0, 0.85);
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-bottom: 20px;
      }
      #leaderboardScreen h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboardScreen ul {
        list-style: none;
        padding: 0;
        max-height: 300px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboardScreen li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboardScreen li:last-child {
        border: none;
      }
      #leaderboardScreen li span:last-child {
        color: #f1c40f;
      }
      #optionsScreen,
      #debugScreen {
        display: none;
      }
      .options-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        margin: 20px 0;
      }
      #right-ui-container {
        position: absolute;
        bottom: 100px;
        right: 20px;
        z-index: 10;
        text-align: right;
        text-shadow: 1px 1px 3px #000;
        opacity: 0.7;
        transition: opacity 0.3s ease-in-out;
      }
      #autofire-indicator {
        font-size: 1.2em;
        color: #e74c3c;
        margin-bottom: 10px;
      }
      #autofire-indicator.active {
        color: #2ecc71;
      }
      #upgrade-inventory {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 5px;
      }
      .inventory-item {
        font-size: 0.7em;
        background: rgba(0, 0, 0, 0.4);
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        gap: 6px;
      }
      #toggleInventoryButton {
        position: absolute;
        bottom: 30px;
        right: 30px;
        width: 60px;
        height: 60px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        cursor: pointer;
        transition: background-color 0.2s;
        z-index: 51;
      }
      #toggleInventoryButton:hover {
        background-color: rgba(0, 255, 255, 0.2);
      }
      #controls-guide {
        position: absolute;
        top: 60vh;
        left: 20px;
        font-size: 0.8em;
        color: #ccc;
        text-shadow: 1px 1px 2px #000;
        line-height: 1.6;
        pointer-events: none;
        z-index: 9;
      }
            #victoryScreen {
        display: none;
        background-color: #0c0a1f;
      }
      #victoryTitle {
        font-size: 4em;
        color: #f1c40f;
        text-shadow: 2px 2px 10px #f1c40f;
        margin-bottom: 20px;
      }
      #victoryStats {
        font-size: 1.1em;
        line-height: 1.8;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border: 1px solid #f1c40f;
        margin-bottom: 30px;
        text-align: left;
        max-width: 600px;
      }
      #victoryStats h3 {
        color: #00ffff;
        margin-top: 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #00ffff;
        padding-bottom: 5px;
      }
      .victory-options {
        display: flex;
        gap: 20px;
      }
    </style>
  </head>
  <body>
    <div id="levelUpFlash"></div>

    <div id="splashScreen" class="screen">
      <div class="splash-content-wrapper">
        <h1>Seraph<br />Defesa Final</h1>
        <div class="splash-buttons">
          <button id="startButton">Iniciar Jogo</button>
          <button id="splashHatShopButton">Classes</button>
          <button id="splashLeaderboardButton">Placar</button>
          <button id="splashWikiButton" class="btn">Wiki</button>
        </div>
        </div>
        <div class="splash-buttons" style="margin-top: 30px">
          <button id="splashOptionsButton" class="btn">Opções</button>
          <button id="splashDebugButton" class="btn">Debug</button>
        </div>
      </div>
    </div>

    <div id="optionsScreen" class="screen">
      <h2>Opções</h2>
      <div class="options-container">
        <button id="aimLineToggle" class="btn">Mira: LIGADA</button>
        <button id="hitboxToggle" class="btn">Hitbox: DESLIGADO</button>
        <button id="enemyHealthToggle" class="btn">Barras HP: LIGADO</button>
        <button id="damageNumbersToggle" class="btn">Nº Dano: LIGADO</button>
        <button id="parallaxToggle" class="btn">Parallax: LIGADO</button>
        <button id="soundToggle" class="btn">Som: LIGADO</button>
        <button id="inventoryToggle" class="btn">Power Ups: LIGADO</button>
      </div>
      <button id="optionsBackButton" class="btn" style="margin-top: 20px">
        Voltar
      </button>
    </div>

    <div id="debugScreen" class="screen">
      <h2>Debug</h2>
      <div class="options-container">
        <button id="unlockAllHatsButton" class="btn">Liberar Classes</button>
        <button id="resetProgressButton" class="btn">Resetar Jogo</button>
      </div>
      <button id="debugBackButton" class="btn" style="margin-top: 20px">
        Voltar
      </button>
    </div>

    <div id="splashHatShopScreen" class="screen">
      <div class="hat-shop-wrapper">
        <h2>
          Classes<br /><span
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 8px;
            "
            ><img src="img/alma.png" style="width: 24px; height: 24px" />
            <span id="splashSoulCount">0</span></span
          >
        </h2>
        <div id="splashHatShopContainer" class="hat-shop-container"></div>
      </div>
      <button id="splashHatShopBackButton" class="btn">Voltar</button>
    </div>

    <div id="leaderboardScreen" class="screen">
      <div class="leaderboard-container">
        <h3>Placar de Líderes</h3>
        <ul id="leaderboard-list-main">
          <li>Carregando...</li>
        </ul>
      </div>
      <button id="clearLeaderboardButton" class="btn">Limpar Placar</button>
      <button id="leaderboardBackButton" class="btn">Voltar</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="top-ui-container">
      <div id="exp-bar-container" class="bar-container">
        <div id="exp-bar" class="bar"></div>
      </div>
    </div>

    <div id="left-ui-container">
      <div id="game-info-text">LVL 1 | Onda 0</div>
      <div id="score-text">Placar: 0</div>
      <div id="timer-text">Tempo: 00:00</div>
    </div>

    <div id="controls-guide">
      A/D para Mover<br />Espaço para Pular<br />S para Queda Rápida<br />R para
      Tiro Automático<br />ESC para Pausar<br />Mouse para Mirar<br />Click para
      Atirar<br />U para Ocultar Controles
    </div>

    <div id="soul-popup">
      <img src="img/alma.png" style="width: 24px; height: 24px" />
      <span id="soul-popup-text">: 0</span>
    </div>

    <div id="waveAnnouncer"></div>
    <div id="right-ui-container">
      <div id="autofire-indicator" style="display: none;"></div>
      <div id="upgrade-inventory"></div>
    </div>

    <div id="levelUpScreen" class="screen">
      <h2 id="levelUpTitle">NÍVEL ALCANÇADO</h2>
      <div id="upgradeCardsContainer"></div>
      <button id="rerollButton">Rerolar</button>
      <div id="toggleInventoryButton" title="Ver/Ocultar Inventário">👁️</div>
    </div>

    <div id="gameOverScreen" class="screen">
      <h1 id="gameOverTitle">FIM DE JOGO</h1>
      <div id="gameOverStats" class="run-summary"></div>
      <div id="leaderboard">
        <h3>Placar de Líderes</h3>
        <div id="score-submission">
          <input
            type="text"
            id="playerNameInput"
            placeholder="Seu Nome"
            maxlength="20"
          />
          <button id="submitScoreBtn" class="btn">Enviar</button>
        </div>
        <div id="submission-message"></div>
        <ul id="leaderboard-list">
          <li>Carregando...</li>
        </ul>
      </div>
      <button id="restartButton">Jogar Novamente</button>
      <button id="backToMenuButton" class="btn">Voltar ao Início</button>
    </div>

    <div id="pauseScreen" class="screen">
      <h2 id="pauseTitle">PAUSADO</h2>
      <button id="resumeButton">Continuar</button>
      <button id="pauseLeaderboardButton" class="btn">Placar</button>
      <button id="pauseOptionsButton" class="btn">Opções</button>
      <button id="pauseWikiButton" class="btn">Wiki</button>
      <button id="pauseShowControlsButton" class="btn">Atalhos</button>
      <button id="restartFromPauseButton">Reiniciar</button>
      <button id="pauseBackToMenuButton" class="btn">Voltar ao Menu</button>
    </div>

    <div id="victoryScreen" class="screen">
      <h1 id="victoryTitle">VITÓRIA!</h1>
      <div id="victoryStats"></div>
      <div class="victory-options">
        <button id="endRunButton" class="btn">Finalizar Corrida</button>
        <button id="continueButton" class="btn">Continuar (Modo Infinito)</button>
      </div>
    </div>

    <div id="wikiScreen" class="screen">
        <h2>Wiki de Upgrades</h2>
        <input type="text" id="wikiSearchBox" placeholder="Buscar por nome, raridade ou efeito...">
        <div id="wikiListContainer" class="wiki-list"></div>
        <button id="wikiBackButton" class="btn">Voltar</button>
    </div>
    <script>
      const d = document,
        canvas = d.getElementById("gameCanvas"),
        ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = !1;
      (canvas.width = window.innerWidth), (canvas.height = window.innerHeight);
      const splashScreen = d.getElementById("splashScreen"),
        startButton = d.getElementById("startButton"),
        levelUpScreen = d.getElementById("levelUpScreen"),
        upgradeCardsContainer = d.getElementById("upgradeCardsContainer"),
        rerollButton = d.getElementById("rerollButton"),
        gameOverScreen = d.getElementById("gameOverScreen"),
        restartButton = d.getElementById("restartButton"),
        waveAnnouncer = d.getElementById("waveAnnouncer"),
        pauseScreen = d.getElementById("pauseScreen"),
        resumeButton = d.getElementById("resumeButton"),
        restartFromPauseButton = d.getElementById("restartFromPauseButton"),
        pauseShowControlsButton = d.getElementById("pauseShowControlsButton"),
        splashHatShopButton = d.getElementById("splashHatShopButton"),
        splashHatShopScreen = d.getElementById("splashHatShopScreen"),
        splashHatShopBackButton = d.getElementById("splashHatShopBackButton"),
        leaderboardScreen = d.getElementById("leaderboardScreen"),
        splashLeaderboardButton = d.getElementById("splashLeaderboardButton"),
        pauseLeaderboardButton = d.getElementById("pauseLeaderboardButton"),
        leaderboardBackButton = d.getElementById("leaderboardBackButton"),
        optionsScreen = d.getElementById("optionsScreen"),
        debugScreen = d.getElementById("debugScreen"),
        splashOptionsButton = d.getElementById("splashOptionsButton"),
        splashDebugButton = d.getElementById("splashDebugButton"),
        pauseOptionsButton = d.getElementById("pauseOptionsButton"),
        optionsBackButton = d.getElementById("optionsBackButton"),
        debugBackButton = d.getElementById("debugBackButton"),
        soundToggle = d.getElementById("soundToggle"),
        aimLineToggle = d.getElementById("aimLineToggle"),
        hitboxToggle = d.getElementById("hitboxToggle"),
        enemyHealthToggle = d.getElementById("enemyHealthToggle"),
        damageNumbersToggle = d.getElementById("damageNumbersToggle"),
        parallaxToggle = d.getElementById("parallaxToggle"),
        inventoryToggle = d.getElementById("inventoryToggle"),
        wikiScreen = d.getElementById("wikiScreen"),
        wikiBackButton = d.getElementById("wikiBackButton"),
        splashWikiButton = d.getElementById("splashWikiButton"),
        pauseWikiButton = d.getElementById("pauseWikiButton");
      const spriteImages = {};
      let wikiReturnScreen = null;
      class SoundManager {
        constructor() {
          this.audioContext = null;
          this.masterGainNode = null;
        }

        init() {
          if (this.audioContext) return;
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGainNode = this.audioContext.createGain();
            this.masterGainNode.connect(this.audioContext.destination);
            this.masterGainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
            if (this.audioContext.state === "suspended") {
              this.audioContext.resume().catch(console.error);
            }
          } catch (e) {
            console.error("Web Audio API is not supported in this browser");
          }
        }

        // Função aprimorada para tocar osciladores com pitch sweep
        playSound(
          freqStart,
          freqEnd,
          duration,
          type = "sine",
          volume = 0.5
        ) {
          if (!gameData.soundEnabled || !this.audioContext) return;
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const now = this.audioContext.currentTime;

          osc.connect(gain);
          gain.connect(this.masterGainNode);

          osc.type = type;
          osc.frequency.setValueAtTime(freqStart, now);
          osc.frequency.exponentialRampToValueAtTime(freqEnd, now + duration * 0.8);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + duration * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          osc.start(now);
          osc.stop(now + duration);
        }

        // Nova função para tocar ruído (ótimo para impactos e explosões)
        playNoise(duration, filterFreq, volume = 0.5, filterType = "bandpass") {
          if (!gameData.soundEnabled || !this.audioContext) return;
          const bufferSize = this.audioContext.sampleRate * duration;
          const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
          const output = buffer.getChannelData(0);

          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }

          const noise = this.audioContext.createBufferSource();
          noise.buffer = buffer;

          const filter = this.audioContext.createBiquadFilter();
          filter.type = filterType;
          filter.Q.value = 1;
          filter.frequency.value = filterFreq;
          
          const gain = this.audioContext.createGain();
          const now = this.audioContext.currentTime;

          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.masterGainNode);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + duration * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          noise.start(now);
          noise.stop(now + duration);
        }

        // --- Novos sons, mais satisfatórios ---

        playShootSound() {
          // Um "pew" com pitch sweep e um clique agudo
          this.playSound(1200, 400, 0.1, "sawtooth", 0.3);
          this.playNoise(0.05, 4000, 0.2, "highpass");
        }

        playEnemyHitSound() {
          // Um "thud" grave com um "crack" agudo
          this.playSound(150, 50, 0.15, "square", 0.4);
          this.playNoise(0.1, 2500, 0.3, "highpass");
        }
        
        playPlayerDamageSound() {
          // Um som grave, distorcido e alarmante
          this.playSound(120, 40, 0.4, "sawtooth", 0.6);
          this.playNoise(0.4, 500, 0.2, "lowpass");
        }

        playJumpSound() {
          // Um "boing" rápido com pitch sweep para cima
          this.playSound(300, 800, 0.12, "sine", 0.4);
        }

        playEnemyDieSound() {
          // Uma pequena explosão grave
          this.playSound(200, 20, 0.2, "sawtooth", 0.5);
          this.playNoise(0.2, 300, 0.4, "lowpass");
        }

        playCollectOrbSound() {
          // Um som mágico e rápido, subindo o tom
          this.playSound(800, 1600, 0.1, "triangle", 0.3);
          this.playSound(1200, 2400, 0.1, "sine", 0.2);
        }

        playHealSound() {
          // Som ascendente e positivo
          this.playSound(500, 1000, 0.3, "sine", 0.5);
          this.playSound(750, 1500, 0.3, "sine", 0.5);
        }

        // Sons que já estavam bons, mantidos
        playLevelUpSound() {
          this.playSound(100, 1000, 0.4, 'sawtooth', 0.4);
          this.playSound(880, 1760, 0.4, 'sine', 0.5);
        }

        playDiceRollSound() {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              this.playNoise(0.1, 1000 + Math.random() * 2000, 0.2);
            }, i * 40);
          }
        }
        
        playUIClickSound() {
          this.playSound(600, 500, 0.1, 'square', 0.2);
        }
        
        playGameOverSound() {
          this.playSound(200, 50, 1, 'sawtooth', 0.5);
        }
      }
      const soundManager = new SoundManager();
      const Starfield = {
        stars: [],
        init() {
          this.stars = [];
          const e = { near: 50, mid: 100, far: 200 },
            t = {
              near: { size: 2, parallax: 0.2 },
              mid: { size: 1.5, parallax: 0.1 },
              far: { size: 1, parallax: 0.05 },
            };
          for (const o in e)
            for (let i = 0; i < e[o]; i++)
              this.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * t[o].size,
                parallax: t[o].parallax,
              });
        },
        update(e) {
          this.stars.forEach((t) => {
            (t.x -= e * t.parallax),
              t.x < 0 && (t.x += canvas.width),
              t.x > canvas.width && (t.x -= canvas.width);
          });
        },
        draw() {
          (ctx.fillStyle = "#fff"),
            this.stars.forEach((e) => {
              ctx.beginPath(),
                ctx.arc(e.x, e.y, e.size / 2, 0, 2 * Math.PI),
                ctx.fill();
            });
        },
      };
      let gameState = "splash";
      const GRAVITY = 0.23;
      let gameTime = 0,
        score = 0,
        runSouls = 0,
        runTimer = 0,
        keys = {},
        mouse = { x: 0, y: 0, down: !1 },
        autoFire = !1,
        player,
        enemies = [],
        pProjs = [],
        eProjs = [],
        particles = [],
        orbs = [],
        wisp = null,
        dNums = [],
        runEnemiesKilled = 0,
        infiniteModeActive = false,
        lightningBolts = [],
        platforms = [],
        soulPopupTimer = null,
        leaderboardReturnScreen = null,
        optionsReturnScreen = null;
      let gameData = {
        totalSouls: 0,
        unlockedHats: ["hat_bruxo"],
        equippedHat: "hat_bruxo",
        soundEnabled: !0,
        aimLineEnabled: !0,
        showHitboxes: !1,
        showEnemyHealthBars: !0,
        showDamageNumbers: !0,
        parallaxEnabled: !0,
        showInventory: !0,
      };
      const HATS = {
        hat_bruxo: {
          name: "Chapéu de Bruxo",
          cost: 25,
          draw: (e) => {
            const t = spriteImages["hat_bruxo.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -50,
                50,
                50
              );
          },
        },
        hat_guerreiro: {
          name: "Elmo de Guerreiro",
          cost: 50,
          draw: (e) => {
            const t = spriteImages["hat_guerreiro.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -45,
                50,
                50
              );
          },
        },
        hat_ladino: {
          name: "Capuz de Ladino",
          cost: 100,
          draw: (e) => {
            const t = spriteImages["hat_ladino.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -48,
                50,
                50
              );
          },
        },
      };
      function loadGameData() {
        try {
          const e = localStorage.getItem("voidSurvivorData");
          e &&
            ((gameData = { ...gameData, ...JSON.parse(e) }),
            (gameData.soundEnabled = !1 !== gameData.soundEnabled),
            (gameData.aimLineEnabled = !1 !== gameData.aimLineEnabled),
            (gameData.showHitboxes = !!gameData.showHitboxes),
            (gameData.showEnemyHealthBars = !!gameData.showEnemyHealthBars),
            (gameData.showDamageNumbers = !!gameData.showDamageNumbers),
            (gameData.parallaxEnabled = !1 !== gameData.parallaxEnabled));
        } catch (e) {
          console.error(e);
        }
      }
      function saveGameData() {
        try {
          localStorage.setItem("voidSurvivorData", JSON.stringify(gameData));
        } catch (e) {
          console.error(e);
        }
      }
      const HAT_SHOP = {
          init(e, t) {
            d.getElementById(t).innerText = gameData.totalSouls;
            const o = d.getElementById(e);
            o.innerHTML = "";
            for (const i in HATS) {
              const s = HATS[i],
                n = d.createElement("div");
              n.className = "hat-card";
              const a = d.createElement("canvas");
              (a.width = 60),
                (a.height = 60),
                this.drawHatPreview(a.getContext("2d"), s);
              const l = d.createElement("button");
              let r;
              gameData.unlockedHats.includes(i)
                ? gameData.equippedHat === i
                  ? ((l.innerText = "Equipado"),
                    (l.disabled = !0),
                    (l.className = "equipped"))
                  : ((l.innerText = "Equipar"), (r = () => this.equip(i, e, t)))
                : ((l.innerText = `Comprar (${s.cost})`),
                  gameData.totalSouls < s.cost
                    ? (l.disabled = !0)
                    : (r = () => this.buy(i, e, t))),
                r &&
                  (l.onclick = () => {
                    soundManager.playUIClickSound(), r();
                  }),
                (n.innerHTML = `<div>${s.name}</div>`),
                n.appendChild(a),
                n.appendChild(l),
                o.appendChild(n);
            }
          },
          drawHatPreview(e, t) {
            const o = e.canvas.width / 2,
              n = e.canvas.height - 5;
            e.save(), e.translate(o, n), t.draw(e), e.restore();
          },
          buy(e, t, o) {
            const i = HATS[e];
            gameData.totalSouls >= i.cost &&
              ((gameData.totalSouls -= i.cost),
              gameData.unlockedHats.push(e),
              saveGameData(),
              this.init(t, o),
              "gameOverHatShopContainer" === t &&
                HAT_SHOP.init("splashHatShopContainer", "splashSoulCount"));
          },
          equip(e, t, o) {
            (gameData.equippedHat = e),
              saveGameData(),
              this.init(t, o),
              "gameOverHatShopContainer" === t &&
                HAT_SHOP.init("splashHatShopContainer", "splashSoulCount");
          },
        },
        groundSegments = [];
      function generateGround() {
        groundSegments.length = 0;
        const segmentWidth = 40;
        let currentY = canvas.height -50;
        const staircaseStartPoint = canvas.width * 0.8; // Inicia a escada em 70% do mapa
        const stepHeight = Math.random() * 35 - 15;

        for (let currentX = 0; currentX < canvas.width; currentX += segmentWidth) {
          if (currentX < staircaseStartPoint) {
            // Parte aleatória do chão
            groundSegments.push({ x: currentX, y: currentY, width: segmentWidth });
            if (Math.random() < 0.4) {
              currentY += Math.random() * 70 - 30; // Variação de -40 a +40
              currentY = Math.max(
                canvas.height - 150, // <-- Valor alterado de 200 para 150
                Math.min(canvas.height - 50, currentY)
              );
            }
          } else {
            // Parte da escada
            currentY -= stepHeight; // Sobe um degrau
            groundSegments.push({ x: currentX, y: currentY, width: segmentWidth });
          }
        }
      }
      function getGroundHeight(e) {
        return groundSegments.length
          ? groundSegments.find((t) => e >= t.x && e < t.x + t.width)?.y ||
              canvas.height
          : canvas.height;
      }
      const allUpgrades = [
        {
          name: "Essência do Vazio",
          description: "Dano do Projétil +2",
          rarity: "common",
          icon: "catalisador.png",
          apply: (e) => (e.stats.projectileDamage += 2),
        },
        {
          name: "Essência do Vazio +",
          description: "Dano do Projétil +4",
          rarity: "uncommon",
          icon: "catalisador2.png",
          apply: (e) => (e.stats.projectileDamage += 4),
        },
        {
          name: "Vigor Primordial",
          description: "HP Máximo +10%",
          rarity: "common",
          icon: "crescimento.png",
          apply: (e) => {
            (e.stats.maxHp *= 1.1),
              (e.hp = Math.min(e.stats.maxHp, e.hp + 0.1 * e.stats.maxHp));
          },
        },
        {
          name: "Vigor Primordial +",
          description: "HP Máximo +20%",
          rarity: "uncommon",
          icon: "crescimento2.png",
          apply: (e) => {
            (e.stats.maxHp *= 1.2),
              (e.hp = Math.min(e.stats.maxHp, e.hp + 0.2 * e.stats.maxHp));
          },
        },
        {
          name: "Vigor Primordial ++",
          description: "HP Máximo +40%",
          rarity: "rare",
          icon: "crescimento3.png",
          apply: (e) => {
            (e.stats.maxHp *= 1.4),
              (e.hp = Math.min(e.stats.maxHp, e.hp + 0.4 * e.stats.maxHp));
          },
        },
        {
          name: "Raio Desintegrador",
          description: "Substitui seus ataques por um raio laser contínuo que causa dano rapidamente onde você mira.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.laserBeam = true),
          isUnique: true,
        },
        {
          name: "Defletor Arcano",
          description: "Projéteis que interceptam disparos inimigos os destroem e absorvem seu poder, aumentando o próprio dano.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.interceptor = true),
          isUnique: true,
        },
        {
          name: "Salto Voltaico",
          description: "Ao atingir um inimigo, seu projétil salta para o inimigo mais próximo. +1 salto por nível.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.chainJumps = (e.stats.chainJumps || 0) + 1),
        },
        {
          name: "Eco Temporal",
          description: "Velocidade de Ataque +12%",
          rarity: "common",
          icon: "ressonancia.png",
          apply: (e) => (e.stats.attackSpeed *= 0.88),
        },
        {
          name: "Eco Temporal +",
          description: "Velocidade de Ataque +24%",
          rarity: "uncommon",
          icon: "ressonancia2.png",
          apply: (e) => (e.stats.attackSpeed *= 0.76),
        },
        {
          name: "Passo Etéreo",
          description: "Velocidade de Movimento +20%",
          rarity: "common",
          icon: "velocidade.png",
          apply: (e) => (e.stats.moveSpeed *= 1.2),
        },
        {
          name: "Passo Etéreo +",
          description: "Velocidade de Movimento +40%",
          rarity: "uncommon",
          icon: "velocidade2.png",
          apply: (e) => (e.stats.moveSpeed *= 1.4),
        },
        {
          name: "Estilhaços Entrópicos",
          description: "Ao morrer, inimigos liberam 2 projéteis fracos",
          rarity: "uncommon",
          icon: "fragmentacao.png",
          apply: (e) => (e.stats.fragmentation += 2),
        },
        {
          name: "Estilhaços Entrópicos +",
          description: "Ao morrer, inimigos liberam 6 projéteis fracos",
          rarity: "rare",
          icon: "fragmentacao2.png",
          apply: (e) => (e.stats.fragmentation += 6),
        },
        {
          name: "Cometa Cinético",
          description:
            "A cada 1000px corridos, lança 1 projétil explosivo para cima",
          rarity: "uncommon",
          icon: "friccao.png",
          apply: (e) => (e.stats.frictionProjectiles += 1),
        },
        {
          name: "Cometa Cinético +",
          description:
            "A cada 1000px corridos, lança 3 projéteis explosivos para cima",
          rarity: "rare",
          icon: "friccao2.png",
          apply: (e) => (e.stats.frictionProjectiles += 3),
        },
        {
          name: "Sifão Vital",
          description: "Roubo de Vida: 3% do dano causado",
          rarity: "uncommon",
          icon: "sanguessuga.png",
          apply: (e) => (e.stats.lifeSteal += 0.03),
        },
        {
          name: "Sifão Vital +",
          description: "Roubo de Vida: 9% do dano causado",
          rarity: "rare",
          icon: "sanguessuga2.png",
          apply: (e) => (e.stats.lifeSteal += 0.09),
        },
        {
          name: "Fúria Celestial",
          description: "Chama 2 relâmpagos do céu a cada 5s",
          rarity: "uncommon",
          icon: "relampago.png",
          apply: (e) => (e.stats.thunderboltCount += 2),
        },
        {
          name: "Fúria Celestial +",
          description: "Chama 6 relâmpagos do céu a cada 5s",
          rarity: "rare",
          icon: "relampago2.png",
          apply: (e) => (e.stats.thunderboltCount += 6),
        },
        {
          name: "Olho do Predador",
          description: "Chance de Crítico +5%",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.stats.critChance += 0.05),
        },
        {
          name: "Salto Gravitacional",
          description: "Altura do Pulo +30%",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.stats.jumpStrength *= 1.3),
        },
        {
          name: "Pulso Restaurador",
          description: "Cura todo o HP",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.hp = e.stats.maxHp),
        },
        {
          name: "Carapaça de Ébano",
          description: "Defesa +4",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.stats.defense += 4),
        },
        {
          name: "Ceifador de Almas",
          description:
            "1% de chance de inimigos droparem um orbe de alma (EXP perm.)",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.stats.soulOrbChance += 0.01),
        },
        {
          name: "Lâmina Perfurante",
          description: "Projéteis perfuram +1 inimigo",
          rarity: "common",
          icon: "common.png",
          apply: (e) => e.stats.projectilePierce++,
        },
        {
          name: "Disparo Hiper-sônico",
          description: "Velocidade do Projétil +25%",
          rarity: "common",
          icon: "common.png",
          apply: (e) => (e.stats.projectileSpeed *= 1.25),
        },
        {
          name: "Singularidade Instável",
          description: "Tamanho do Projétil +20%",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.projectileSize *= 1.2),
        },
        {
          name: "Manto Espectral",
          description: "+10% mais tempo de invulnerabilidade após ser atingido",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.invulnerabilityTime *= 1),
        },
        {
          name: "Oráculo do Acaso",
          description: "Ganha +1 carga de Rerolar por subida de nível.",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => e.stats.rerollCharges++,
        },
        {
          name: "Pluma Ascendente",
          description: "Ganha +1 pulo extra",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => e.stats.maxJumps++,
        },
        {
          name: "Dádiva do Destino",
          description: "Chance aumentada de obter melhorias incomuns/raras",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.luck += 0.1),
        },
        {
          name: "Bênção de Vida",
          description:
            "5% de chance de inimigos mortos droparem um orbe de cura",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.healOrbChance += 0.05),
        },
        {
          name: "Golpe Fatal",
          description: "Acertos críticos causam +50% de dano",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.critDamage += 0.5),
        },
        {
          name: "Coração Berserker",
          description:
            "Com menos de 50% de HP, ganha um bônus de dano (até +50%)",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.rage = !0),
        },
        {
          name: "Simbiose com a Horda",
          description: "Regenera HP com base no nº de inimigos vivos",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.hpRegenPerEnemy += 0.005),
        },
        {
          name: "Contração Dimensional",
          description: "Fica 10% menor",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => {
            (e.width *= 0.9), (e.height *= 0.9);
          },
        },
        {
          name: "Fome de Conhecimento",
          description: "Ganha 20% mais EXP de todas as fontes.",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.expGainModifier *= 1.2),
        },
        {
          name: "Mente Expandida",
          description: "+1 escolha de melhoria por subida de nível",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => e.stats.upgradeChoices++,
        },
        {
          name: "Égide de Nulidade",
          description: "Cria um escudo que bloqueia 1 golpe a cada 15s",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.barrier = !0),
        },
        {
          name: "Toque Congelante",
          description: "Inimigos ficam 1% mais lentos por acerto (máx 80%)",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.cold = !0),
        },
        {
          name: "Meditação de Batalha",
          description:
            "Ganha velocidade de ataque a cada segundo que fica parado",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.focus = !0),
        },
        {
          name: "Vontade Inquebrável",
          description: "+1 ressurreição (mata todos os inimigos ao reviver)",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => e.stats.revives++,
          isUnique: !0,
        },
        {
          name: "Aura Solar",
          description: "Seu corpo causa 40 de dano de contato aos inimigos",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.contactDamage += 40),
        },
        {
          name: "Tomo do Potencial",
          description:
            "Melhorias comuns (brancas) que você escolhe se tornam 35% mais eficazes",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.tome = !0),
        },
        {
          name: "Gêmeo Espectral",
          description:
            "Invoca um fogo-fátuo que herda metade do seu dano e velocidade de ataque",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => {
            wisp || ((wisp = new Wisp(e)), (e.stats.hasWisp = !0));
          },
        },
        {
          name: "Hemorragia Cósmica",
          description:
            "Causar dano aos inimigos faz com que eles sangrem com o tempo",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.wound = !0),
        },
      ];
      let availableUpgrades = [...allUpgrades];
      class Player {
        constructor() {
          (this.width = 50),
            (this.height = 90),
            (this.x = canvas.width / 2),
            (this.y = canvas.height - 200),
            (this.vx = 0),
            (this.vy = 0),
            (this.onGround = !1),
            (this.jumpsLeft = 0),
            (this.hp = 100),
            (this.exp = 0),
            (this.level = 1),
            (this.expToNextLevel = 100),
            (this.invulnerableTimer = 0),
            (this.shootCooldown = 0),
            (this.distanceTraveled = 0),
            (this.stillTimer = 0),
            (this.laserDamageTick = 0),
            (this.upgrades = new Map()),
            (this.stats = this.getBaseStats());
        }
        getBaseStats() {
          return {
            maxHp: 100,
            moveSpeed: 3.2 * 0.6,
            jumpStrength: 15 * 0.7,
            maxJumps: 1,
            attackSpeed: 700,
            projectileDamage: 10,
            projectileSpeed: 8 * 0.6,
            projectileSize: 5,
            projectilePierce: 1,
            critChance: 0.05,
            critDamage: 1.5,
            defense: 0,
            invulnerabilityTime: 100,
            luck: 0,
            upgradeChoices: 3,
            rerollCharges: 1,
            lifeSteal: 0,
            expGainModifier: 1.2,
            rage: !1,
            hpRegenPerEnemy: 0,
            healOrbChance: 0,
            soulOrbChance: 0,
            contactDamage: 0,
            fragmentation: 0,
            frictionProjectiles: 0,
            thunderboltCount: 0,
            barrier: !1,
            barrierReady: !0,
            barrierCooldown: 15e3,
            barrierTimer: 0,
            cold: !1,
            focus: !1,
            revives: 0,
            tome: !1,
            hasWisp: !1,
            wound: !1,
            laserBeam: false,   // Novo
            interceptor: false, // Novo
            chainJumps: 0, 
          };
        }
        getWeaponTip() {
          const e = this.x + this.width / 2,
            t = this.y + this.height / 2 - 20,
            i = e + 15,
            s = t - 10,
            n = Math.atan2(mouse.y - s, mouse.x - i),
            a = 60,
            l = i + Math.cos(n) * a,
            r = s + Math.sin(n) * a;
          return { x: l, y: r, angle: n };
        }
        update(e) {
          let t = !1;
          keys.a || keys.A
            ? ((this.vx = -this.stats.moveSpeed), (t = !0))
            : keys.d || keys.D
            ? ((this.vx = this.stats.moveSpeed), (t = !0))
            : (this.vx = 0),
            t
              ? ((this.distanceTraveled += Math.abs(this.vx)),
                (this.stillTimer = 0))
              : (this.stillTimer += e),
            (this.vy += GRAVITY),
            !this.onGround && (keys.s || keys.S) && (this.vy += 0.6),
            (this.y += this.vy);

          let onSurface = false;
          if (this.vy >= 0) {
            for (const p of platforms) {
              if (
                this.x < p.x + p.width &&
                this.x + this.width > p.x &&
                this.y + this.height >= p.y &&
                this.y + this.height - this.vy <= p.y + 1
              ) {
                this.y = p.y - this.height;
                this.vy = 0;
                onSurface = true;
                break;
              }
            }
            if (!onSurface) {
              const groundY = getGroundHeight(this.x + this.width / 2);
              if (this.y + this.height >= groundY) {
                this.y = groundY - this.height;
                this.vy = 0;
                onSurface = true;
              }
            }
          }
          if (onSurface) {
            if (!this.onGround) {
              this.jumpsLeft = this.stats.maxJumps;
            }
            this.onGround = true;
          } else {
            this.onGround = false;
          }

          // CÓDIGO DE MOVIMENTO HORIZONTAL REINSERIDO AQUI
          (this.x += this.vx),
          this.x < 0 && (this.x = 0),
          this.x + this.width > canvas.width &&
            (this.x = canvas.width - this.width),
          // FIM DO CÓDIGO REINSERIDO

          this.invulnerableTimer > 0 && (this.invulnerableTimer -= e); // Estava faltando
          this.laserDamageTick > 0 && (this.laserDamageTick -= e);
          this.shootCooldown > 0 && (this.shootCooldown -= e);

          if (this.stats.laserBeam) {
            if ((mouse.down || autoFire) && this.laserDamageTick <= 0) {
              this.laserDamageTick = this.stats.attackSpeed / 5; // Ticks de dano rápidos
              const { x: startX, y: startY } = this.getWeaponTip();
              const angle = Math.atan2(mouse.y - startY, mouse.x - startX);
              
              // Raycast simplificado para encontrar o primeiro inimigo
              let laserTarget = null;
              let minDistance = Infinity;
              for(const enemy of enemies) {
                // ... (a lógica completa do raycast é complexa, aqui está uma aproximação)
                const distToPlayer = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (distToPlayer < minDistance) {
                   const angleToEnemy = Math.atan2(enemy.y + enemy.height / 2 - startY, enemy.x + enemy.width / 2 - startX);
                   if (Math.abs(angle - angleToEnemy) < 0.2) { // Se o inimigo está no "cone" do laser
                       laserTarget = enemy;
                       minDistance = distToPlayer;
                   }
                }
              }

              if (laserTarget) {
                  laserTarget.takeDamage(this.stats.projectileDamage / 4, Math.random() < this.stats.critChance);
              }
            }
          } else {
            (mouse.down || autoFire) &&
              this.shootCooldown <= 0 &&
              (this.shoot(),
              (this.shootCooldown = this.stats.focus
                ? this.stats.attackSpeed / (1 + this.stillTimer / 5e3)
                : this.stats.attackSpeed));
          }
          this.updateSpecial(e);
        }
        updateSpecial(e) {
          if (
            this.stats.frictionProjectiles > 0 &&
            this.distanceTraveled >= 1e3
          ) {
            for (let t = 0; t < this.stats.frictionProjectiles; t++)
              pProjs.push(
                new PlayerProjectile(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  -Math.PI / 2, // Ângulo para cima
                  40, // Dano do projétil explosivo
                  true // É explosivo
                )
              );
            this.distanceTraveled = 0;
          }
          this.stats.barrier &&
            !this.stats.barrierReady &&
            ((this.stats.barrierTimer += e),
            this.stats.barrierTimer >= this.stats.barrierCooldown &&
              ((this.stats.barrierReady = !0), (this.stats.barrierTimer = 0))),
            this.stats.hpRegenPerEnemy > 0 &&
              this.heal(
                (enemies.length * this.stats.hpRegenPerEnemy * e) / 1e3
              );
        }
        draw() {
          const e = this.x + this.width / 2,
            t = this.y + this.height / 2;
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "yellow"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          if (
            !(
              this.invulnerableTimer > 0 &&
              Math.floor(Date.now() / 100) % 2 == 0
            )
          ) {
            ctx.save(), ctx.translate(e, t);
            const a = spriteImages["corpo.png"];
            a && a.complete
              ? ctx.drawImage(a, -30, -30, 60, 80)
              : ((ctx.strokeStyle = "#fff"),
                (ctx.lineWidth = 2),
                ctx.beginPath(),
                ctx.moveTo(0, -this.height / 2),
                ctx.lineTo(this.width / 2, this.height / 2),
                ctx.lineTo(-this.width / 2, this.height / 2),
                ctx.closePath(),
                ctx.stroke());
            ctx.save(),
              ctx.translate(0, -this.height / 2 + 30),
              gameData.equippedHat &&
                HATS[gameData.equippedHat] &&
                HATS[gameData.equippedHat].draw(ctx),
              ctx.restore();
            const s = Math.atan2(mouse.y - t, mouse.x - e),
              i = spriteImages["wpn_staff.png"];
            if (i && i.complete) {
              ctx.save(),
                ctx.translate(15, -10),
                ctx.rotate(s + 1.4708),
                ctx.drawImage(i, -10, -55, 20, 70),
                ctx.restore();
            } else {
              const r = 0.8 * this.height,
                h = Math.cos(s) * r,
                c = Math.sin(s) * r;
              (ctx.strokeStyle = "#00ffff"),
                (ctx.lineWidth = 4),
                ctx.beginPath(),
                ctx.moveTo(0, 0),
                ctx.lineTo(h, c),
                ctx.stroke(),
                (ctx.fillStyle = "#00ffff"),
                ctx.beginPath(),
                ctx.arc(h, c, 5, 0, 2 * Math.PI),
                ctx.fill();
            }
            this.stats.barrier &&
              this.stats.barrierReady &&
              ((ctx.strokeStyle = "rgba(100,200,255,.8)"),
              (ctx.lineWidth = 3),
              ctx.beginPath(),
              ctx.arc(0, 0, 5 + this.height / 2, 0, 2 * Math.PI),
              ctx.stroke());
            const p = 60,
              l = 8,
              d = this.hp / this.stats.maxHp,
              y = -this.height / 2 - 20;
            (ctx.fillStyle = "rgba(0,0,0,0.5)"),
              ctx.fillRect(-p / 2, y, p, l),
              (ctx.fillStyle = "#c0392b"),
              ctx.fillRect(-p / 2, y, p * d, l),
              (ctx.strokeStyle = "rgba(255,255,255,0.7)"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(-p / 2, y, p, l);
            const txt = `${Math.ceil(this.hp)}/${Math.ceil(this.stats.maxHp)}`;
            (ctx.font = "10px 'Press Start 2P'"),
              (ctx.textAlign = "center"),
              (ctx.textBaseline = "middle"),
              (ctx.fillStyle = "#000"),
              ctx.fillText(txt, 0, y + l / 2 + 1),
              (ctx.fillStyle = "#fff"),
              ctx.fillText(txt, 0, y + l / 2),
              ctx.restore();
          }
          if (gameData.aimLineEnabled) {
            const { x: n, y: u } = this.getWeaponTip();
            let g = !1;
            for (const m of enemies)
              if (
                mouse.x > m.x &&
                mouse.x < m.x + m.width &&
                mouse.y > m.y &&
                mouse.y < m.y + m.height
              ) {
                g = !0;
                break;
              }
            ctx.beginPath(),
              ctx.moveTo(n, u),
              ctx.lineTo(mouse.x, mouse.y),
              (ctx.strokeStyle = g
                ? "rgba(255,100,100,0.25)"
                : "rgba(255,255,255,0.1)"),
              (ctx.lineWidth = 1),
              ctx.stroke();
          }
          if (this.stats.laserBeam && (mouse.down || autoFire)) {
            const { x: startX, y: startY } = this.getWeaponTip();
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.strokeStyle = "#ff4747";
            ctx.lineWidth = 3 + Math.random() * 2;
            ctx.shadowColor = "#ff0000";
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.restore();
          }
        }
        jump() {
          if (this.jumpsLeft > 0) {
            soundManager.playJumpSound();
            this.vy = -this.stats.jumpStrength;
            this.jumpsLeft--;
            this.onGround = false;
          }
        }
        shoot() {
          soundManager.playShootSound();
          const { x: e, y: t, angle: o } = this.getWeaponTip();
          pProjs.push(new PlayerProjectile(e, t, o));
        }
        takeDamage(e) {
          if (this.invulnerableTimer > 0) return;
          if (this.stats.barrier && this.stats.barrierReady)
            return (
              (this.stats.barrierReady = !1),
              void (this.invulnerableTimer = 500)
            );
          soundManager.playPlayerDamageSound();
          const t = Math.max(1, e - this.stats.defense);
          if (
            ((this.hp -= t),
            (this.invulnerableTimer = this.stats.invulnerabilityTime),
            this.hp <= 0)
          )
            if (this.stats.revives > 0)
              this.stats.revives--,
                (this.hp = this.stats.maxHp),
                enemies.forEach((e) => (e.hp = 0)),
                (availableUpgrades = availableUpgrades.filter(
                  (e) => "Vontade Inquebrável" !== e.name
                ));
            else {
              soundManager.playGameOverSound(),
                (gameState = "gameOver"),
                saveGameData(),
                (gameOverScreen.style.display = "flex");

              let upgradesHTML = '';
              if (this.upgrades.size > 0) {
                upgradesHTML = '<h3>Upgrades Adquiridos:</h3><div style="display: flex; flex-wrap: wrap; gap: 5px;">';
                for (const [name, count] of this.upgrades) {
                  const upgradeData = allUpgrades.find(u => u.name === name);
                  upgradesHTML += `<div class="inventory-item">${upgradeData.icon ? `<img src="img/${upgradeData.icon}" style="width: 16px; height: 16px; image-rendering: pixelated;">` : ''} <span>${name} (${count})</span></div>`;
                }
                upgradesHTML += '</div>';
              }

              d.getElementById("gameOverStats").innerHTML = `
                <strong>Pontuação Final:</strong> ${score}<br>
                <strong>Onda Concluída:</strong> ${currentWave}<br>
                <strong>Inimigos Derrotados:</strong> ${runEnemiesKilled}<br>
                <strong>Tempo:</strong> ${formatTime(runTimer)}<br>
                ${upgradesHTML}`;
              
              Leaderboard.show();
            }
        }
        heal(e) {
          this.hp = Math.min(this.stats.maxHp, this.hp + e);
        }
        gainExp(e) {
          const t = e * this.stats.expGainModifier;
          (this.exp += t),
            (score += e),
            this.exp >= this.expToNextLevel && this.levelUp();
        }
        levelUp() {
          this.level++,
            (this.exp -= this.expToNextLevel),
            (this.expToNextLevel = Math.floor(1.5 * this.expToNextLevel)),
            (this.hp = this.stats.maxHp),
            (this.rerollsLeft = this.stats.rerollCharges),
            soundManager.playLevelUpSound(),
            triggerLevelUp();
        }
        
        gainRandomRareUpgrade() {
            const rareUpgrades = allUpgrades.filter(u => u.rarity === 'rare' && (!u.isUnique || !this.upgrades.has(u.name)));
            if (rareUpgrades.length > 0) {
                const chosenUpgrade = rareUpgrades[Math.floor(Math.random() * rareUpgrades.length)];
                
                // Aplica a melhoria
                chosenUpgrade.apply(this);
                if (chosenUpgrade.isUnique) {
                    availableUpgrades = availableUpgrades.filter(u => u.name !== chosenUpgrade.name);
                }
                const currentCount = this.upgrades.get(chosenUpgrade.name) || 0;
                this.upgrades.set(chosenUpgrade.name, currentCount + 1);
                
                // Mostra um anúncio visual da recompensa
                waveAnnouncer.innerText = `RECOMPENSA: ${chosenUpgrade.name}`;
                waveAnnouncer.style.opacity = 1;
                setTimeout(() => {
                    waveAnnouncer.style.opacity = 0;
                }, 3000); // Mostra por 3 segundos

                updateInventoryUI();
            }
        }
      }
      class DamageNumber {
        constructor(e, t, o, i) {
          (this.x = e),
            (this.y = t),
            (this.text = o),
            (this.isCrit = i),
            (this.life = 60),
            (this.vy = -1);
        }
        update() {
          (this.y += this.vy), (this.vy += 0.03), this.life--;
        }
        draw() {
          ctx.save(),
            (ctx.globalAlpha = Math.max(0, this.life / 60)),
            (ctx.fillStyle = this.isCrit ? "#f1c40f" : "#fff"),
            (ctx.font = this.isCrit
              ? "bold 18px Courier New"
              : "14px Courier New"),
            (ctx.textAlign = "center"),
            ctx.fillText(this.text, this.x, this.y),
            ctx.restore();
        }
      }
      let currentWave = 0,
        waveState = "intermission",
        intermissionTimer = 3e3;
      const ENEMY_TYPES = {};
      const WAVE_DEFS = [
        { wave: 1, enemies: { LacaioDoVazio: 3 } },
        { wave: 2, enemies: { LacaioDoVazio: 5 } },
        { wave: 3, enemies: { LacaioDoVazio: 7 } },
        { wave: 4, enemies: { LacaioDoVazio: 5, SentinelaEspectral: 1 } },
        { wave: 5, enemies: { LacaioDoVazio: 8, SentinelaEspectral: 2 } },
        { wave: 6, enemies: { GuardiaoAnomalo: 1, LacaioDoVazio: 4 } },
        { wave: 7, enemies: { GuardiaoAnomalo: 1, SentinelaEspectral: 2 } },
        { wave: 8, enemies: { LacaioDoVazio: 10, SentinelaEspectral: 3 } },
        { wave: 9, enemies: { GuardiaoAnomalo: 2, LacaioDoVazio: 5 } },
        {
          wave: 10,
          enemies: {
            GuardiaoAnomalo: 1,
            LacaioDoVazio: 8,
            SentinelaEspectral: 4,
          },
        },
      ];
     function updateWaveSystem(e) {
        if (gameState !== 'playing') return;

        if ("intermission" === waveState) {
          if (currentWave >= 15 && enemies.length === 0 && !infiniteModeActive) {
             showVictoryScreen();
             return;
          }

          intermissionTimer -= e;
          if (intermissionTimer <= 0) {
            currentWave++;
            spawnWave(currentWave);
            waveState = "fighting";
            const waveText = (currentWave % 5 === 0 && currentWave > 0) ? "CHEFE" : `ONDA ${currentWave}`;
            waveAnnouncer.innerText = waveText;
            waveAnnouncer.style.opacity = 1;
            setTimeout(() => {
              waveAnnouncer.style.opacity = 0;
            }, 2e3);
          }
        } else if ("fighting" === waveState && enemies.length === 0) {
          waveState = "intermission";
          intermissionTimer = 3e3;
        }
      }

      function spawnWave(e) {
        enemies.length = 0; // Limpa inimigos de ondas anteriores

        if (e % 5 === 0 && e > 0) { // Onda de Boss
            const waveDefForHP = createProceduralWave(e);
            const bossHP = calculateWaveHP(waveDefForHP);
            enemies.push(new BossEnemy(bossHP, e)); // Passa a onda para o Boss
        } else { // Onda normal
            let waveDef = WAVE_DEFS.find((t) => t.wave === e) || createProceduralWave(e);
            for (const enemyName in waveDef.enemies) {
                for (let i = 0; i < waveDef.enemies[enemyName]; i++) {
                    if (ENEMY_TYPES[enemyName]) {
                        // Passa a onda para o construtor do inimigo
                        enemies.push(new ENEMY_TYPES[enemyName](e));
                    }
                }
            }

            if (e % 3 === 0 && e > 0) { // Adiciona um Elite
                if (enemies.length > 0) {
                    enemies.shift(); // Remove um inimigo para dar lugar ao elite
                }
                enemies.push(new EliteEnemy(e)); // Passa a onda para o Elite
            }
        }
      }
      function createProceduralWave(e) {
        let t = 1.5 * e;
        const o = {
          LacaioDoVazio: 0,
          SentinelaEspectral: 0,
          GuardiaoAnomalo: 0,
        };
        for (; t > 0; )
          t >= 4 && Math.random() < 0.4
            ? (o.GuardiaoAnomalo++, (t -= 4))
            : t >= 2 && Math.random() < 0.5
            ? (o.SentinelaEspectral++, (t -= 2))
            : (o.LacaioDoVazio++, (t -= 1));
        return { wave: e, enemies: o };
      }
      class Enemy {
        constructor(wave = 1) { // Aceita a onda, com padrão 1
          (this.x = Math.random() * (canvas.width - 50) + 25),
            (this.y = -50),
            (this.chaseHeight = canvas.height * (0.15 + 0.2 * Math.random())),
            (this.state = "descending"),
            (this.shootTimer = 1e3 * Math.random()),
            (this.slowFactor = 1),
            (this.bleedTimer = 0),
            (this.bleedDamage = 0),
            (this.hitFlashTimer = 0);
          this.wave = wave; // Armazena a onda
          this.scaleFactor = 1 + (this.wave - 1) * 0.1;
        }
        update(e) {
          if ("descending" === this.state)
            (this.y += this.speed),
              this.y > this.chaseHeight && (this.state = "chasing");
          else if ("chasing" === this.state) {
            let h = 0;
            enemies.forEach((u) => {
              if (u === this) return;
              const d = Math.hypot(this.x - u.x, this.y - u.y),
                c = this.width + 10;
              d < c && d > 0 && (h += (this.x - u.x) / d);
            });
            const t =
              this.chaseHeight + 20 * Math.sin(gameTime / 1e3 + this.x / 50);
            let o = player.x + player.width / 2;
            "sniper" === this.aiType &&
              Math.abs(o - this.x) < 400 &&
              (o = this.x - 100 * Math.sign(o - this.x));
            const i = Math.atan2(t - this.y, o - this.x);
            (this.x +=
              Math.cos(i) * this.speed * this.slowFactor +
              h * 0.5 * this.speed),
              (this.y += 0.5 * Math.sin(i) * this.speed * this.slowFactor),
              (this.shootTimer += e),
              this.shootTimer >= this.shootCooldown &&
                (this.shoot(), (this.shootTimer = 0));
          }
          if (this.x < 0) this.x = 0;
          if (this.x + this.width > canvas.width)
            this.x = canvas.width - this.width;
          this.bleedDamage > 0 &&
            ((this.bleedTimer += e),
            this.bleedTimer >= 1e3 &&
              (this.takeDamage(this.bleedDamage, !1, !0),
              (this.bleedTimer = 0))),
            checkCollision(this, player) &&
              (player.takeDamage(this.damage),
              player.stats.contactDamage > 0 &&
                this.takeDamage(player.stats.contactDamage));
          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
        }
        drawHealthBar() {
          if (!gameData.showEnemyHealthBars) return;
          (ctx.fillStyle = "#333"),
            ctx.fillRect(this.x, this.y - 10, this.width, 5),
            (ctx.fillStyle = "#e74c3c"),
            ctx.fillRect(
              this.x,
              this.y - 10,
              this.width * (this.hp / this.maxHp),
              5
            ),
            (ctx.fillStyle = "#fff"),
            (ctx.font = '10px "Courier New"'),
            (ctx.textAlign = "center"),
            ctx.fillText(
              `${Math.ceil(this.hp)}/${this.maxHp}`,
              this.x + this.width / 2,
              this.y - 14
            ),
            (ctx.textAlign = "left");
        }
        drawHitFlash() {
          if (this.hitFlashTimer > 0) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }
        }
        takeDamage(e, t = !1, o = !1) {
          if (!o) {
            soundManager.playEnemyHitSound();
            this.hitFlashTimer = 100; // Duração do flash em ms
          }
          gameData.showDamageNumbers &&
            dNums.push(
              new DamageNumber(
                this.x + this.width / 2,
                this.y,
                Math.round(e),
                t
              )
            ),
            (this.hp -= e),
            this.hp <= 0 && !o && this.die();
        }
        die() {
          runEnemiesKilled++;
          soundManager.playEnemyDieSound(),
            player.gainExp(this.expValue),
            Math.random() < 0.8 &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "soul_currency"
                )
              ),
            player.stats.fragmentation > 0 &&
                Array.from({ length: player.stats.fragmentation }).forEach(() => {
                let t = null;
                enemies.length > 0 &&
                  (t = enemies[Math.floor(Math.random() * enemies.length)]);
                const o = t
                  ? Math.atan2(t.y - this.y, t.x - this.x)
                  : 2 * Math.random() * Math.PI;
                eProjs.push(
                    new EnemyProjectile(
                    this.x + this.width / 2,
                    this.y + this.height / 2,
                    o,
                    player.stats.projectileDamage / 3 // Dano baseado no dano do jogador
                    )
                );
              }),
            Math.random() < player.stats.healOrbChance &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "heal"
                )
              ),
            Math.random() < player.stats.soulOrbChance &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "soul"
                )
              );
        }
      }
      class LacaioDoVazio extends Enemy {
        constructor(wave) {
          super(wave); // Passa a onda para a classe pai
            (this.width = 42),
            (this.height = 42),
            (this.speed = 0.7 + 0.3 * Math.random() * 0.6),
            (this.maxHp = Math.round(26 * this.scaleFactor)), // Aplica o scaling
            (this.hp = this.maxHp),
            (this.damage = Math.round(6 * this.scaleFactor)), // Aplica o scaling
            (this.expValue = Math.round(40 * this.scaleFactor)), // Aplica o scaling
            (this.shootCooldown = 2400),
            (this.color = "#ff00ff"),
            (this.aiType = "standard");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo2.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage
            )
          );
        }
      }
      class GuardiaoAnomalo extends Enemy {
        constructor(wave) {
          super(wave),
            (this.width = 60),
            (this.height = 60),
            (this.speed = 0.35 * 0.6),
            this.maxHp = Math.round(114 * this.scaleFactor);
            this.hp = this.maxHp;
            this.damage = Math.round(14 * this.scaleFactor);
            this.expValue = Math.round(180 * this.scaleFactor);
            (this.shootCooldown = 4200),
            (this.color = "#e67e22"),
            (this.aiType = "standard");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo3.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage,
              10,
              3
            )
          );
        }
      }
      class SentinelaEspectral extends Enemy {
        constructor(wave) {
          super(wave),
            (this.width = 30),
            (this.height = 30),
            (this.speed = 1.1 * 0.6),
            this.maxHp = Math.round(18 * this.scaleFactor);
          this.hp = this.maxHp;
          this.damage = Math.round(9 * this.scaleFactor);
          this.expValue = Math.round(85 * this.scaleFactor);
            (this.shootCooldown = 1600),
            (this.color = "#2ecc71"),
            (this.aiType = "sniper");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo1.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage,
              4,
              8
            )
          );
        }
      }

      class EliteEnemy extends GuardiaoAnomalo {
        constructor(wave) {
          super(wave); // Herda o scaling do Guardião
          this.width *= 1.5;
          this.height *= 1.5;
          this.maxHp *= 2; // Dobra o HP já escalado
          this.hp = this.maxHp;
          this.damage *= 2; // Dobra o dano já escalado
          this.expValue *= 3;
          this.color = "#ffd700";
        }
        draw() {
          super.draw();
        }
        die() {
          super.die();
          player.levelUp(); // Garante 1 nível
          player.rerollsLeft++; // Garante 1 reroll
          createExplosion(this.x + this.width / 2, this.y + this.height / 2, this.color, 50);
        }
      }

      class BossEnemy extends Enemy {
        constructor(hp, wave) {
          super(wave);
          this.width = 150;
          this.height = 150;
          this.speed = 0.5 * 0.6;
          this.maxHp = hp; // O HP do Boss já é calculado com base na onda
          this.hp = this.maxHp;
          this.damage = Math.round(25 * this.scaleFactor); // Escala apenas o dano
          this.expValue = Math.round(1000 * this.scaleFactor);
          this.color = "#e74c3c";
          this.aiType = "boss";
          this.attackPattern = ["shotgun", "rain", "dash"];
          this.currentAttack = 0;
          this.attackTimer = 0;
          this.attackCooldown = 4000;
        }

        update(e) {
          super.update(e);
          this.attackTimer += e;
          if (this.attackTimer >= this.attackCooldown) {
            this.executeAttack();
            this.attackTimer = 0;
            this.currentAttack = (this.currentAttack + 1) % this.attackPattern.length;
          }
        }

        die() {
            super.die();
            // Adiciona a recompensa de skill rara
            player.gainRandomRareUpgrade();
        }

        executeAttack() {
          const attackType = this.attackPattern[this.currentAttack];
          if (attackType === "shotgun") {
            const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
            for (let i = -2; i <= 2; i++) {
              const angle = angleToPlayer + i * (Math.PI / 18);
              eProjs.push(new EnemyProjectile(this.x + this.width / 2, this.y + this.height / 2, angle, this.damage * 0.7, 8));
            }
          } else if (attackType === "rain") {
            for (let i = 0; i < 10; i++) {
              const spawnX = Math.random() * canvas.width;
              eProjs.push(new EnemyProjectile(spawnX, -20, Math.PI / 2, this.damage * 0.5, 6, 5));
            }
          } else if (attackType === "dash") {
            const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
            this.vx = Math.cos(angleToPlayer) * this.speed * 5; // Dash rápido
            this.vy = Math.sin(angleToPlayer) * this.speed * 5;
            setTimeout(() => { this.vx = 0; this.vy = 0; }, 500); // Para após 0.5s
          }
        }
        
        draw() {
          this.drawHealthBar();
          const img = spriteImages["inimigo3.png"];
          if (img && img.complete) {
            ctx.drawImage(img, this.x, this.y, this.width, this.height);
            ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
            ctx.beginPath();
            ctx.arc(
              this.x + this.width / 2,
              this.y + this.height / 2,
              this.width / 2,
              0,
              2 * Math.PI
            );
            ctx.fill();
          }
        }
        
        shoot() { /* O ataque é controlado pelo executeAttack */ }
      }
      
      (ENEMY_TYPES.LacaioDoVazio = LacaioDoVazio),
        (ENEMY_TYPES.GuardiaoAnomalo = GuardiaoAnomalo),
        (ENEMY_TYPES.SentinelaEspectral = SentinelaEspectral),
        (ENEMY_TYPES.EliteEnemy = EliteEnemy),
        (ENEMY_TYPES.BossEnemy = BossEnemy);
      
      class Projectile {
        constructor(e, t, o, i, s = 8) {
          (this.x = e),
            (this.y = t),
            (this.angle = o),
            (this.damage = i),
            (this.speed = s),
            (this.vx = Math.cos(o) * this.speed),
            (this.vy = Math.sin(o) * this.speed),
            (this.active = !0);
        }
        update() {
          (this.x += this.vx), (this.y += this.vy);
          if (this.y >= getGroundHeight(this.x)) {
            this.active = !1;
            let e = "#fff";
            this instanceof PlayerProjectile && (e = "#00ffff"),
              this instanceof EnemyProjectile && (e = "#ff0000"),
              createExplosion(this.x, this.y, e);
          }
          this.isOffScreen() && (this.active = !1);
        }
        isOffScreen() {
          return (
            this.x < 0 ||
            this.x > canvas.width ||
            this.y < 0 ||
            this.y > canvas.height
          );
        }
      }

      function calculateWaveHP(waveDef) {
          let totalHP = 0;
          for (const enemyName in waveDef.enemies) {
              const count = waveDef.enemies[enemyName];
              if (ENEMY_TYPES[enemyName]) {
                  const tempEnemy = new ENEMY_TYPES[enemyName]();
                  totalHP += tempEnemy.maxHp * count;
              }
          }
          return totalHP > 0 ? totalHP : 500; // Garante que tenha HP mesmo se o cálculo falhar
      }
      class PlayerProjectile extends Projectile {
        constructor(e, t, o, i = null, s = !1) {
          super(e, t, o, void 0, player.stats.projectileSpeed),
            (this.radius = player.stats.projectileSize),
            (this.pierceLeft = player.stats.projectilePierce),
            (this.explosive = s),
            (this.trail = []); 
          let n = null !== i ? i : player.stats.projectileDamage;
          player.stats.rage &&
            player.hp < player.stats.maxHp / 2 &&
            (n *= 1 + (1 - player.hp / (player.stats.maxHp / 2)) * 0.5),
            (this.isCrit = Math.random() < player.stats.critChance),
            this.isCrit && (n *= player.stats.critDamage),
            (this.damage = n);
           this.jumpsLeft = player.stats.chainJumps;
        }
        update() {
          super.update();
          const trailColor = this.isCrit ? "#f1c40f" : "#00ffff";
          particles.push(new Particle(this.x, this.y, trailColor, 0.5, 20));
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > 5) {
            this.trail.shift();
          }
        }
        draw() {
          ctx.save();
          for (let i = 0; i < this.trail.length; i++) {
              const pos = this.trail[i];
              const opacity = (i / this.trail.length) * 0.8; // Opacidade aumentada
              const radius = this.radius * (i / this.trail.length);
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
              ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
              ctx.fill();
          }
          ctx.restore();

          if (gameData.showHitboxes) {
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 1;
            ctx.strokeRect(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
          }

          // Efeito de brilho (glow)
          ctx.save();
          ctx.shadowColor = this.isCrit ? "#f1c40f" : "#00ffff";
          ctx.shadowBlur = 15;

          // Núcleo do projétil
          ctx.fillStyle = this.isCrit ? "#f1c40f" : "#00ffff";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.restore();

          if (this.explosive) {
            ctx.strokeStyle = "#e67e22";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 2, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
        onHit(e) {
          if (!this.active) return;

          e.takeDamage(this.damage, this.isCrit);
          if (player.stats.lifeSteal > 0) player.heal(this.damage * player.stats.lifeSteal);
          if (player.stats.cold) e.slowFactor = Math.max(0.2, e.slowFactor * 0.99);
          if (player.stats.wound) e.bleedDamage += 0.1 * this.damage;

          if (this.jumpsLeft > 0) {
            this.jumpsLeft--;
            let closestEnemy = null;
            let minDistance = Infinity;
            for (const otherEnemy of enemies) {
              if (otherEnemy !== e && otherEnemy.hp > 0) {
                const distance = Math.hypot(this.x - otherEnemy.x, this.y - otherEnemy.y);
                if (distance < minDistance) {
                  minDistance = distance;
                  closestEnemy = otherEnemy;
                }
              }
            }
            if (closestEnemy) {
              const newAngle = Math.atan2(closestEnemy.y + closestEnemy.height / 2 - this.y, closestEnemy.x + closestEnemy.width / 2 - this.x);
              this.angle = newAngle;
              this.vx = Math.cos(newAngle) * this.speed;
              this.vy = Math.sin(newAngle) * this.speed;
              this.damage *= 0.8; // Dano reduzido a cada salto
              return; // Projétil continua ativo
            }
          }
          
          this.pierceLeft--;
          if (this.pierceLeft <= 0) this.active = !1;
        }
      }
      class EnemyProjectile extends Projectile {
        constructor(e, t, o, i, s = 5, n = 4 * 0.6) {
          // Agora o parâmetro `i` (dano) é usado corretamente
          super(e, t, o, i, n), (this.radius = s);
        }
        draw() {
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "#ff8888"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(
                this.x - this.radius,
                this.y - this.radius,
                2 * this.radius,
                2 * this.radius
              );
          }
          (ctx.fillStyle = "#ff0000"),
            (ctx.strokeStyle = "#fff"),
            (ctx.lineWidth = 1),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
            ctx.fill(),
            ctx.stroke();
        }
      }
      class Particle {
        constructor(e, t, o, speedMultiplier = 1, life = 50) {
          (this.x = e),
            (this.y = t),
            (this.color = o),
            (this.radius = 3 * Math.random() + 1),
            (this.vx = 4 * (Math.random() - 0.5) * speedMultiplier),
            (this.vy = 4 * (Math.random() - 0.5) * speedMultiplier),
            (this.life = life);
        }
        update() {
          (this.x += this.vx),
            (this.y += this.vy),
            (this.vy += 0.1),
            this.life--;
        }
        draw() {
          (ctx.globalAlpha = this.life / 50),
            (ctx.fillStyle = this.color),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
            ctx.fill(),
            (ctx.globalAlpha = 1);
        }
      }
      function createExplosion(e, t, o = "#fff", i = 15) {
        for (let s = 0; s < i; s++) particles.push(new Particle(e, t, o));
      }
      class Orb {
        constructor(e, t, o) {
          (this.x = e),
            (this.y = t),
            (this.type = o),
            (this.radius = 8),
            (this.color =
              "heal" === o ? "lime" : "soul" === o ? "violet" : "#add8e6"),
            (this.vy = -2),
            (this.life = 500),
            (this.onGround = !1);
        }
        update() {
          this.onGround || ((this.y += this.vy), (this.vy += 0.035)),
            this.life--;
          const e = getGroundHeight(this.x);
          this.y + this.radius > e
            ? ((this.y = e - this.radius), (this.vy = 0), (this.onGround = !0))
            : (this.onGround = !1);
          const t = player.x + player.width / 2 - this.x,
            o = player.y + player.height / 2 - this.y,
            i = Math.hypot(t, o);
          i < 150 && ((this.x += (t / i) * 5), (this.y += (o / i) * 5)),
            checkCollision(
              {
                x: this.x - this.radius,
                y: this.y - this.radius,
                width: 2 * this.radius,
                height: 2 * this.radius,
              },
              player
            ) && this.collect();
        }
        draw() {
          if ("soul_currency" === this.type || "soul" === this.type) {
            const e = spriteImages["alma.png"];
            e && e.complete
              ? ctx.drawImage(e, this.x - 16, this.y - 16, 28, 28)
              : ((ctx.fillStyle = this.color),
                ctx.beginPath(),
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
                ctx.fill());
          } else
            (ctx.fillStyle = this.color),
              ctx.beginPath(),
              ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
              ctx.fill(),
              (ctx.strokeStyle = "white"),
              (ctx.lineWidth = 1),
              ctx.stroke();
        }
        collect() {
          if ("heal" === this.type)
            player.heal(0.1 * player.stats.maxHp), soundManager.playHealSound();
          else if ("soul" === this.type)
            player.gainExp(50), soundManager.playCollectOrbSound();
          else if ("soul_currency" === this.type) {
            (gameData.totalSouls += 1),
              (runSouls += 1),
              soundManager.playCollectOrbSound();
            const e = d.getElementById("soul-popup"),
              t = d.getElementById("soul-popup-text");
            (t.innerText = `: ${runSouls}`),
              e.classList.add("active"),
              soulPopupTimer && clearTimeout(soulPopupTimer),
              (soulPopupTimer = setTimeout(() => {
                e.classList.remove("active");
              }, 2e3));
          } else soundManager.playCollectOrbSound();
          this.life = 0;
        }
      }
      class Wisp {
        constructor(e) {
          (this.owner = e),
            (this.x = e.x - 50),
            (this.y = e.y),
            (this.angle = 0),
            (this.shootCooldown = 0);
        }
        update(e) {
          this.angle += 0.02;
          const t =
              this.owner.x + this.owner.width / 2 + 75 * Math.cos(this.angle),
            o = this.owner.y + 75 * Math.sin(this.angle);
          (this.x += 0.1 * (t - this.x)),
            (this.y += 0.1 * (o - this.y)),
            this.shootCooldown > 0 && (this.shootCooldown -= e);
          if (enemies.length > 0 && this.shootCooldown <= 0) {
            let i = enemies.reduce((e, t) =>
              Math.hypot(t.x - this.x, t.y - this.y) <
              Math.hypot(e.x - this.x, e.y - this.y)
                ? t
                : e
            );
            i &&
              (this.shoot(i),
              (this.shootCooldown = 2 * this.owner.stats.attackSpeed));
          }
        }
        shoot(e) {
          const t = Math.atan2(e.y - this.y, e.x - this.x);
          pProjs.push(
            new PlayerProjectile(
              this.x + 10 * Math.cos(t),
              this.y + 10 * Math.sin(t),
              t,
              player.stats.projectileDamage / 2
            )
          );
        }
        draw() {
          (ctx.fillStyle = "rgba(155,89,182,.8)"),
            (ctx.strokeStyle = "#fff"),
            (ctx.lineWidth = 1),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, 10, 0, 2 * Math.PI),
            ctx.fill(),
            ctx.stroke();
        }
      }
      function formatTime(t) {
        const e = Math.floor(t / 6e4)
            .toString()
            .padStart(2, "0"),
          o = Math.floor((t % 6e4) / 1e3)
            .toString()
            .padStart(2, "0");
        return `${e}:${o}`;
      }
      const Leaderboard = {
        show() {
          this.loadAndDisplayScores("leaderboard-list");
        },
        loadAndDisplayScores(e) {
          const t = d.getElementById(e);
          if (!t) return;
          try {
            const o = localStorage.getItem("voidSurvivorLeaderboard"),
              i = o ? JSON.parse(o) : [];
            t.innerHTML =
              0 === i.length
                ? "<li>Nenhuma pontuação ainda. Seja o primeiro!</li>"
                : i
                    .map(
                      (e) =>
                        `<li><span>${e.name}</span><span>${e.score}${
                          e.time ? ` (${formatTime(e.time)})` : ""
                        }</span></li>`
                    )
                    .join("");
          } catch (o) {
            (t.innerHTML = "<li>Erro ao carregar pontuações.</li>"),
              console.error(o);
          }
        },
        submitScore() {
          const e = d.getElementById("playerNameInput"),
            t = d.getElementById("submission-message"),
            o = e.value.trim();
          if (!o)
            return (
              (t.textContent = "Por favor, insira um nome."),
              void (t.className = "error")
            );
          d.getElementById("submitScoreBtn").disabled = !0;
          try {
            const i = localStorage.getItem("voidSurvivorLeaderboard");
            let s = i ? JSON.parse(i) : [];
            s.push({ name: o, score: score, time: runTimer }),
              s.sort((e, t) => t.score - e.score),
              s.length > 10 && (s = s.slice(0, 10)),
              localStorage.setItem(
                "voidSurvivorLeaderboard",
                JSON.stringify(s)
              ),
              (t.textContent = "Pontuação enviada!"),
              (t.className = ""),
              (d.getElementById("score-submission").style.display = "none"),
              this.loadAndDisplayScores("leaderboard-list");
          } catch (i) {
            (t.textContent = "Falha ao enviar pontuação."),
              (t.className = "error"),
              (d.getElementById("submitScoreBtn").disabled = !1),
              console.error(i);
          }
        },
        clearScores() {
          try {
            localStorage.removeItem("voidSurvivorLeaderboard"),
              this.loadAndDisplayScores("leaderboard-list-main"),
              this.loadAndDisplayScores("leaderboard-list");
          } catch (e) {
            console.error(e);
          }
        },
      };
      let thunderboltTimer = 0;
      const THUNDERBOLT_COOLDOWN = 5e3;
      function handleThunderbolts(e) {
        if (
          player.stats.thunderboltCount > 0 &&
          ((thunderboltTimer += e), thunderboltTimer >= 5e3)
        ) {
          thunderboltTimer = 0;
          for (let t = 0; t < player.stats.thunderboltCount; t++) {
            let o = Math.random() * canvas.width;
            if (enemies.length > 0) {
              const i = enemies[Math.floor(Math.random() * enemies.length)];
              o = i.x + i.width / 2;
            }
            const i = player.stats.projectileDamage;
            const groundY = getGroundHeight(o);
            
            // Cria um objeto de raio em vez de desenhar diretamente
            lightningBolts.push(new LightningBolt(o, groundY));
            
            // A cor da explosão agora combina com o raio
            createExplosion(o, groundY, "#00ffff", 30);

            enemies.forEach((e) => {
              Math.abs(e.x + e.width / 2 - o) < 25 && e.takeDamage(i, !0);
            });
          }
        }
      }
      function checkCollision(e, t) {
        return (
          e.x < t.x + t.width &&
          e.x + e.width > t.x &&
          e.y < t.y + t.height &&
          e.y + e.height > t.y
        );
      }
      function getRarityPool() {
        const e = Math.random(),
          t = 0.1 + 0.5 * player.stats.luck,
          o = 0.3 + player.stats.luck;
        return e < t ? "rare" : e < t + o ? "uncommon" : "common";
      }
      function triggerLevelUp() {
        const l = d.getElementById("levelUpFlash");
        l.classList.add("active"),
          (l.onanimationend = () => l.classList.remove("active")),
          (gameState = "levelUp"),
          (levelUpScreen.style.display = "flex"),
          (d.getElementById("autofire-indicator").style.display = "none"),
          (d.getElementById("right-ui-container").style.opacity = "0"), // Esconde a UI do inventário
          (upgradeCardsContainer.innerHTML = "");
        let e = [];
        const t = player.stats.upgradeChoices,
          o = availableUpgrades.filter(
            (e) =>
              !("Fogo-Fátuo" === e.name && player.stats.hasWisp) &&
              !("Imortal" === e.name && player.stats.revives > 0)
          );
        for (let i = 0; i < t; i++) {
          let s = getRarityPool(),
            n = o.filter(
              (t) => t.rarity === s && !e.find((e) => e.name === t.name)
            );
          0 === n.length &&
            (n = o.filter((t) => !e.find((e) => e.name === t.name))),
            n.length > 0 && e.push(n[Math.floor(Math.random() * n.length)]);
        }
        e.forEach((e) => {
          if (!e) return;
          const t = d.createElement("div"),
            o = { common: "comum", uncommon: "incomum", rare: "raro" },
            i =
              e.icon && spriteImages[e.icon]
                ? `<div class="card-icon"><img src="${
                    spriteImages[e.icon].src
                  }" alt="${e.name}"></div>`
                : '<div class="card-icon"></div>';
          (t.className = `upgrade-card rarity-${e.rarity}`),
            (t.innerHTML = `${i}<div class="card-header"><h3>${
              e.name
            }</h3><div class="card-rarity">${
              o[e.rarity]
            }</div></div><div class="card-divider"></div><p class="card-description">${
              e.description
            }</p>`),
            (t.onclick = () => selectUpgrade(e)),
            upgradeCardsContainer.appendChild(t);
        }),
          (rerollButton.innerHTML = `<img src="img/dado.png" style="vertical-align: middle; width: 22px; height: 22px; margin-right: 8px;"> Rerolar (${player.rerollsLeft} restante(s))`),
          (rerollButton.disabled = player.rerollsLeft <= 0);
      }
      function selectUpgrade(e) {
        soundManager.playUIClickSound(),
          player.stats.tome && "common" === e.rarity
            ? e.apply(player)
            : e.apply(player),
          e.isUnique &&
            (availableUpgrades = availableUpgrades.filter(
              (t) => t.name !== e.name
            ));
        const t = player.upgrades.get(e.name) || 0;
        player.upgrades.set(e.name, t + 1),
          updateInventoryUI(),
          (gameState = "playing"),
          (levelUpScreen.style.display = "none"),
          (d.getElementById("right-ui-container").style.opacity = "0.7"), // Garante que a UI do inventário reapareça
          updateAutofireIndicator(),
          (lastTime = performance.now()),
          requestAnimationFrame(gameLoop);
      }
      rerollButton.onclick = () => {
        if (player.rerollsLeft > 0) {
          soundManager.playDiceRollSound();
          player.rerollsLeft--;
          triggerLevelUp();
        }
      };
      class LightningBolt {
        constructor(startX, endY) {
          this.path = [];
          this.life = 15; // Vida em frames, controla o tempo na tela
          let currentX = startX;
          let currentY = 0;
          this.path.push({ x: currentX, y: currentY });

          while (currentY < endY) {
            currentX += (Math.random() * 30 - 15);
            currentY += Math.random() * 20 + 10;
            this.path.push({ x: currentX, y: Math.min(currentY, endY) });
          }
        }

        update() {
          this.life--;
        }

        draw() {
          ctx.save();
          // Cor ciano/branca brilhante para o raio
          ctx.strokeStyle = `rgba(200, 255, 255, ${this.life / 15 * 0.9})`; // Efeito de fade-out
          ctx.lineWidth = 4;
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 20;

          ctx.beginPath();
          ctx.moveTo(this.path[0].x, this.path[0].y);
          for (let i = 1; i < this.path.length; i++) {
            ctx.lineTo(this.path[i].x, this.path[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
      }
      function drawGround() {
        if (groundSegments.length === 0) return;
        (ctx.fillStyle = "#1a1a2a"),
          ctx.beginPath(),
          ctx.moveTo(0, canvas.height),
          ctx.lineTo(0, groundSegments[0].y);
        for (const e of groundSegments) ctx.lineTo(e.x + e.width, e.y);
        ctx.lineTo(canvas.width, canvas.height),
          ctx.closePath(),
          ctx.fill(),
          (ctx.strokeStyle = "#9b59b6"),
          (ctx.lineWidth = 2.5),
          ctx.beginPath(),
          ctx.moveTo(0, groundSegments[0].y);
        for (const e of groundSegments) ctx.lineTo(e.x + e.width, e.y);
        ctx.stroke();
      }
            function generatePlatforms() {
        platforms.length = 0;
        // Plataforma média na direita
        platforms.push({
          x: canvas.width - 450,
          y: canvas.height - 300,
          width: 250,
          height: 25,
        });
      }
      function drawPlatforms() {
        ctx.fillStyle = "#1a1a2a";
        ctx.strokeStyle = "#9b59b6";
        ctx.lineWidth = 2.5;
        platforms.forEach((p) => {
          ctx.beginPath();
          ctx.rect(p.x, p.y, p.width, p.height);
          ctx.fill();
          ctx.stroke();
        });
      }
      let lastTime = 0;
      function updateInventoryVisibility() {
        d.getElementById('right-ui-container').style.display = gameData.showInventory ? 'block' : 'none';
      }
      function gameLoop(e) {
        if ("playing" !== gameState) {
          // Renderiza o jogo em modo "pausado" no fundo de telas como gameOver e victory
          if (gameState === "gameOver" || gameState === 'victory') {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             Starfield.draw();
             drawGround();
             drawPlatforms();
             [particles, orbs, pProjs, eProjs, enemies].forEach((item) => item.forEach((i) => i.draw()));
             wisp && wisp.draw();
             player.draw();
             dNums.forEach((dn) => dn.draw());
          }
          updateInventoryVisibility(); // Usa a nova função aqui também
          const t = Math.min(50, e - lastTime);
          return;
        }
        const t = Math.min(50, e - lastTime);
        (lastTime = e),
          (gameTime += t),
          (runTimer += t),
          player.update(t),
          wisp && wisp.update(t),
          Starfield.update(gameData.parallaxEnabled ? player.vx : 0),
          updateWaveSystem(t),
          handleThunderbolts(t),
          [enemies, pProjs, eProjs, particles, orbs, dNums, lightningBolts].forEach((e) =>
            e.forEach((e) => e.update(t))
          ),
          pProjs.forEach((e) =>
            enemies.forEach((t) => {
              e.active &&
                t.hp > 0 &&
                checkCollision(
                  {
                    x: e.x - e.radius,
                    y: e.y - e.radius,
                    width: 2 * e.radius,
                    height: 2 * e.radius,
                  },
                  t
                ) &&
                e.onHit(t);
            })
          ),
          eProjs.forEach((e) => {
            e.active &&
              checkCollision(
                {
                  x: e.x - e.radius,
                  y: e.y - e.radius,
                  width: 2 * e.radius,
                  height: 2 * e.radius,
                },
                player
              ) &&
              (player.takeDamage(e.damage), (e.active = !1));
          }),
          (enemies = enemies.filter((e) => e.hp > 0)),
          (pProjs = pProjs.filter((e) => e.active)),
          (eProjs = eProjs.filter((e) => e.active)),
          (particles = particles.filter((e) => e.life > 0)),
          (orbs = orbs.filter((o) => o.life > 0)),
          (dNums = dNums.filter((e) => e.life > 0)),
          (lightningBolts = lightningBolts.filter((lb) => lb.life > 0)),
          ctx.clearRect(0, 0, canvas.width, canvas.height),
          Starfield.draw(),
          drawGround(),
          drawPlatforms(),
          [particles, orbs, pProjs, eProjs, enemies].forEach((e) =>
            e.forEach((e) => e.draw())
          ),
          wisp && wisp.draw(),
          player.draw(),
          lightningBolts.forEach((lb) => lb.draw()),
          dNums.forEach((e) => e.draw()),
          (d.getElementById("exp-bar").style.width = `${
            (player.exp / player.expToNextLevel) * 100
          }%`),
          (d.getElementById("score-text").innerText = `Placar: ${score}`),
          (d.getElementById(
            "game-info-text"
          ).innerText = `LVL ${player.level} | Onda ${currentWave}`),
          (d.getElementById("timer-text").innerText = `Tempo: ${formatTime(
            runTimer
          )}`),
          requestAnimationFrame(gameLoop);
      }
    function resetGame() {
        (keys = {}),
          (gameTime = 0),
          (score = 0),
          (runSouls = 0),
          (runTimer = 0),
          (runEnemiesKilled = 0),
          (infiniteModeActive = false),
          (lightningBolts = []),
          (autoFire = !1),
          (enemies = []),
          (pProjs = []),
          (eProjs = []),
          (particles = []),
          (orbs = []),
          (dNums = []),
          (wisp = null),
          (platforms = []),
          (availableUpgrades = [...allUpgrades]),
          generateGround(),
          generatePlatforms(),
          Starfield.init(),
          (player = new Player()),
          updateInventoryUI(),
          updateAutofireIndicator(),
          (gameOverScreen.style.display = "none"),
          (pauseScreen.style.display = "none"),
          (d.getElementById("score-submission").style.display = "block"),
          (d.getElementById("playerNameInput").value = ""),
          (d.getElementById("submission-message").textContent = ""),
          (d.getElementById("submitScoreBtn").disabled = !1),
          (gameState = "playing"),
          (currentWave = 0),
          (waveState = "intermission"),
          (intermissionTimer = 1e3);
      }
      function togglePause() {
        "playing" === gameState
          ? ((gameState = "paused"), (pauseScreen.style.display = "flex"))
          : "paused" === gameState &&
            ((gameState = "playing"),
            (pauseScreen.style.display = "none"),
            (lastTime = performance.now()),
            requestAnimationFrame(gameLoop));
      }
      function updateToggleButton(e, t, o, i) {
        e.innerText = `${o}: ${t ? i[0] : i[1]}`;
      }
      function toggleAndSave(e, t) {
        (gameData[e] = !gameData[e]),
          soundManager.playUIClickSound(),
          t(),
          saveGameData();
      }
      function updateAllToggleButtons() {
        updateToggleButton(soundToggle, gameData.soundEnabled, "Som", [
          "LIGADO",
          "DESLIGADO",
        ]),
          updateToggleButton(aimLineToggle, gameData.aimLineEnabled, "Mira", [
            "LIGADA",
            "DESLIGADA",
          ]),
          updateToggleButton(hitboxToggle, gameData.showHitboxes, "Hitbox", [
            "LIGADO",
            "DESLIGADO",
          ]),
          updateToggleButton(
            enemyHealthToggle,
            gameData.showEnemyHealthBars,
            "Barras HP",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(
            damageNumbersToggle,
            gameData.showDamageNumbers,
            "Nº Dano",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(
            parallaxToggle,
            gameData.parallaxEnabled,
            "Parallax",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(inventoryToggle, gameData.showInventory, "Power Ups", [
            "LIGADO",
            "DESLIGADO",
          ]);
      }
      function startGameSequence() {
        soundManager.playUIClickSound(),
          resetGame(),
          (lastTime = performance.now()),
          requestAnimationFrame(gameLoop),
          setTimeout(() => {
            d.getElementById("controls-guide").style.display = "none";
          }, 2e3);
      }
      function loadAssets(e) {
        const t = new Set();
        allUpgrades.forEach((e) => {
          e.icon
            ? t.add(e.icon)
            : "common" === e.rarity
            ? t.add("common.png")
            : "uncommon" === e.rarity
            ? t.add("uncommon.png")
            : t.add("rare.png");
        }),
          t.add("hat_bruxo.png"),
          t.add("hat_guerreiro.png"),
          t.add("hat_ladino.png"),
          t.add("alma.png"),
          t.add("corpo.png"),
          t.add("wpn_staff.png"),
          t.add("inimigo1.png"),
          t.add("inimigo2.png"),
          t.add("inimigo3.png");
          t.add("dado.png");
        const o = Array.from(t);
        let i = 0;
        if (0 === o.length) return void e();
        (startButton.innerText = "Carregando..."),
          (startButton.disabled = !0),
          o.forEach((t) => {
            const s = new Image();
            (s.src = `img/${t}`),
              (spriteImages[t] = s),
              (s.onload = () => {
                i++,
                  i === o.length &&
                    ((startButton.innerText = "Iniciar Jogo"),
                    (startButton.disabled = !1),
                    e());
              }),
              (s.onerror = () => {
                console.error(`Erro ao carregar: img/${t}`),
                  i++,
                  i === o.length &&
                    ((startButton.innerText = "Iniciar Jogo"),
                    (startButton.disabled = !1),
                    e());
              });
          });
      }
      // Modularize event listeners and utility functions
      const switchScreen = (e, t, o) => {
        e && (e.style.display = "none"),
          t && (d.getElementById(t).style.display = "flex"),
          o && (gameState = o);
      };
      function populateWiki(filter = "") {
        const container = d.getElementById("wikiListContainer");
        container.innerHTML = "";
        const rarityOrder = { "common": 1, "uncommon": 2, "rare": 3 };
        const sortedUpgrades = [...allUpgrades].sort((a,b) => rarityOrder[a.rarity] - rarityOrder[b.rarity]);
        
        const lowerCaseFilter = filter.toLowerCase();

        sortedUpgrades
          .filter(u => 
            u.name.toLowerCase().includes(lowerCaseFilter) ||
            u.rarity.toLowerCase().includes(lowerCaseFilter) ||
            u.description.toLowerCase().includes(lowerCaseFilter)
          )
          .forEach(u => {
            const itemDiv = d.createElement("div");
            itemDiv.className = "wiki-item";
            const icon = u.icon ? `<img src="img/${u.icon}" style="width: 24px; height: 24px; image-rendering: pixelated;">` : "";
            itemDiv.innerHTML = `
              <h3>${icon} ${u.name} <span class="rarity rarity-${u.rarity}" style="color: ${{"common":"#fff", "uncommon":"#3498db", "rare":"#9b59b6"}[u.rarity]}">${u.rarity}</span></h3>
              <p>${u.description}</p>
            `;
            container.appendChild(itemDiv);
          });
      }
      function setupEventListeners() {
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());
         window.addEventListener("keydown", (e) => {
          keys[e.key] = !0;

          if (e.key === "Escape") {
            e.preventDefault(); // Impede outros comportamentos do ESC

            if (optionsScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(optionsScreen, optionsReturnScreen);
              return;
            }
            if (leaderboardScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(leaderboardScreen, leaderboardReturnScreen);
              return;
            }
            if (wikiScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(wikiScreen, wikiReturnScreen);
              return;
            }

            // Se nenhuma tela de menu estiver aberta, pause/despause o jogo
            if (gameState === "playing" || gameState === "paused") {
              togglePause();
            }
            return;
          }

          if ("q" === e.key || "Q" === e.key) {
            gameData.showInventory = !gameData.showInventory;
            updateAllToggleButtons();
            updateInventoryVisibility(); // Chama a nova função aqui
            return;
          }

          const t = d.getElementById("controls-guide");
          if ("u" === e.key || "U" === e.key) {
            t.style.display = "none" === t.style.display ? "block" : "none";
          } else if (gameState === "playing") {
            if (" " === e.key || "Space" === e.code) {
              e.preventDefault(), player.jump();
            } else if ("r" === e.key || "R" === e.key) {
              (autoFire = !autoFire), updateAutofireIndicator();
            }
          }
        }),
          window.addEventListener("keyup", (e) => {
            keys[e.key] = !1;
          }),
          window.addEventListener("mousemove", (e) => {
            (mouse.x = e.clientX), (mouse.y = e.clientY);
          }),
          window.addEventListener("mousedown", (e) => {
            0 === e.button && (mouse.down = !0);
          }),
          window.addEventListener("mouseup", (e) => {
            0 === e.button && (mouse.down = !1);
          });
        restartButton.addEventListener("click", startGameSequence),
          restartFromPauseButton.addEventListener("click", startGameSequence),
          resumeButton.addEventListener("click", () => {
            soundManager.playUIClickSound(), togglePause();
          }),
          splashHatShopButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              HAT_SHOP.init("splashHatShopContainer", "splashSoulCount"),
              switchScreen(splashScreen, "splashHatShopScreen");
          }),
          splashHatShopBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(splashHatShopScreen, "splashScreen");
          }),
          soundToggle.addEventListener("click", () =>
            toggleAndSave("soundEnabled", updateAllToggleButtons)
          ),
          aimLineToggle.addEventListener("click", () =>
            toggleAndSave("aimLineEnabled", updateAllToggleButtons)
          ),
          hitboxToggle.addEventListener("click", () =>
            toggleAndSave("showHitboxes", updateAllToggleButtons)
          ),
          enemyHealthToggle.addEventListener("click", () =>
            toggleAndSave("showEnemyHealthBars", updateAllToggleButtons)
          ),
          damageNumbersToggle.addEventListener("click", () =>
            toggleAndSave("showDamageNumbers", updateAllToggleButtons)
          ),
          parallaxToggle.addEventListener("click", () =>
            toggleAndSave("parallaxEnabled", updateAllToggleButtons)
          ),
          inventoryToggle.addEventListener("click", () =>
            toggleAndSave("showInventory", updateAllToggleButtons)
          ),
          splashOptionsButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (optionsReturnScreen = "splashScreen"),
              switchScreen(splashScreen, "optionsScreen");
          }),
          splashDebugButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(splashScreen, "debugScreen");
          }),
          pauseOptionsButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (optionsReturnScreen = "pauseScreen"),
              switchScreen(pauseScreen, "optionsScreen");
          }),
          optionsBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(optionsScreen, optionsReturnScreen);
          }),
          debugBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(debugScreen, "splashScreen");
          }),
          d
            .getElementById("submitScoreBtn")
            .addEventListener("click", () => Leaderboard.submitScore()),
          d.getElementById("backToMenuButton").addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(gameOverScreen, "splashScreen", "splash");
          }),
          d
            .getElementById("pauseBackToMenuButton")
            .addEventListener("click", () => {
              soundManager.playUIClickSound(),
                switchScreen(pauseScreen, "splashScreen", "splash");
            }),
          splashLeaderboardButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (leaderboardReturnScreen = "splashScreen"),
              switchScreen(splashScreen, "leaderboardScreen"),
              Leaderboard.loadAndDisplayScores("leaderboard-list-main");
          }),
          pauseLeaderboardButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (leaderboardReturnScreen = "pauseScreen"),
              switchScreen(pauseScreen, "leaderboardScreen"),
              Leaderboard.loadAndDisplayScores("leaderboard-list-main");
          }),
          leaderboardBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(leaderboardScreen, leaderboardReturnScreen);
          }),
          d
            .getElementById("clearLeaderboardButton")
            .addEventListener("click", () => {
              soundManager.playUIClickSound(), Leaderboard.clearScores();
            });
        
        // Listener do "Olho" (que estava faltando no exemplo anterior)
        d.getElementById("toggleInventoryButton").addEventListener(
          "click",
          () => {
            soundManager.playUIClickSound();
            const inventoryUI = d.getElementById("right-ui-container");
            if (inventoryUI.style.opacity === "0") {
              inventoryUI.style.opacity = "0.7";
              inventoryUI.style.zIndex = "52";
            } else {
              inventoryUI.style.opacity = "0";
              inventoryUI.style.zIndex = "10";
            }
          }
        );

        // Listener do botão de atalhos (que estava faltando no exemplo anterior)
        pauseShowControlsButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          const controlsGuide = d.getElementById("controls-guide");
          if (
            controlsGuide.style.display === "none" ||
            controlsGuide.style.display === ""
          ) {
            controlsGuide.style.display = "block";
            controlsGuide.style.zIndex = "51";
          } else {
            controlsGuide.style.display = "none";
            controlsGuide.style.zIndex = "9";
          }
        });
        
        // -- INÍCIO DO CÓDIGO NOVO ADICIONADO --
        d.getElementById("continueButton").addEventListener("click", () => {
          soundManager.playUIClickSound();
          infiniteModeActive = true;
          d.getElementById("victoryScreen").style.display = "none";
          gameState = "playing";
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
        });

        d.getElementById("endRunButton").addEventListener("click", () => {
           soundManager.playUIClickSound();
           d.getElementById("victoryScreen").style.display = "none";
           gameState = "gameOver";
           gameOverScreen.style.display = "flex";
           d.getElementById("gameOverTitle").innerText = "CORRIDA FINALIZADA";
           d.getElementById("gameOverStats").innerHTML = `Pontuação Final: ${score}<br>Onda Concluída: ${currentWave}<br>Inimigos Derrotados: ${runEnemiesKilled}<br>Tempo: ${formatTime(runTimer)}`;
           Leaderboard.show();
           HAT_SHOP.init("gameOverHatShopContainer", "gameOverSoulCount");
        });

        splashWikiButton.addEventListener("click", () => {
            soundManager.playUIClickSound();
            wikiReturnScreen = "splashScreen";
            switchScreen(splashScreen, "wikiScreen");
        });

        pauseWikiButton.addEventListener("click", () => {
            soundManager.playUIClickSound();
            wikiReturnScreen = "pauseScreen";
            switchScreen(pauseScreen, "wikiScreen");
        });

        wikiBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound();
            switchScreen(wikiScreen, wikiReturnScreen);
        });

        d.getElementById("wikiSearchBox").addEventListener("input", (e) => {
          populateWiki(e.target.value);
        });

        // -- FIM DO CÓDIGO NOVO ADICIONADO --
      }

      // Adicione esta nova função DEPOIS da função setupEventListeners
      function showVictoryScreen() {
          gameState = 'victory';
          const statsDiv = d.getElementById('victoryStats');
          let upgradesHTML = '<h3>Upgrades Adquiridos:</h3><div style="display: flex; flex-wrap: wrap; gap: 5px;">';
          for(const [name, count] of player.upgrades) {
              const upgradeData = allUpgrades.find(u => u.name === name);
              upgradesHTML += `<div class="inventory-item">${upgradeData.icon ? `<img src="img/${upgradeData.icon}" style="width: 16px; height: 16px; image-rendering: pixelated;">` : ''} <span>${name} (${count})</span></div>`;
          }
          upgradesHTML += '</div>';

          statsDiv.innerHTML = `
              <strong>Pontuação:</strong> ${score}<br>
              <strong>Inimigos Derrotados:</strong> ${runEnemiesKilled}<br>
              <strong>Tempo Total:</strong> ${formatTime(runTimer)}<br>
              ${upgradesHTML}
          `;
          d.getElementById('victoryScreen').style.display = 'flex';
      }
      function resetProgress() {
        confirm(
          "Deseja mesmo resetar todo o progresso? Isso é irreversível."
        ) &&
          (soundManager.playUIClickSound(),
          localStorage.removeItem("voidSurvivorData"),
          localStorage.removeItem("voidSurvivorLeaderboard"),
          location.reload());
      }
      function unlockAllHats() {
        soundManager.playUIClickSound(),
          (gameData.unlockedHats = Object.keys(HATS)),
          saveGameData(),
          alert("Todas as classes foram liberadas!");
      }
      function updateAutofireIndicator() {
        const e = d.getElementById("autofire-indicator");
        if (e) {
          if (autoFire) {
            e.textContent = "AUTO: ON";
            e.classList.add("active");
            e.style.display = "block";
          } else {
            e.style.display = "none";
            e.classList.remove("active");
          }
        }
      }
      function updateInventoryUI() {
        const inventoryContainer = d.getElementById("upgrade-inventory");
        inventoryContainer.innerHTML = "";
        if (player && player.upgrades.size > 0) {
          for (const [name, count] of player.upgrades) {
            const itemDiv = d.createElement("div");
            itemDiv.className = "inventory-item";

            const upgradeData = allUpgrades.find((u) => u.name === name);
            let iconHtml = "";
            if (upgradeData && upgradeData.icon) {
              iconHtml = `<img src="img/${upgradeData.icon}" style="width: 18px; height: 18px; image-rendering: pixelated;">`;
            }

            itemDiv.innerHTML = `${iconHtml}<span>${name} (${count})</span>`;
            inventoryContainer.appendChild(itemDiv);
          }
        }
      }
      function init() {
        loadGameData(),
        updateAllToggleButtons(),
        populateWiki(),
        loadAssets(() => {
            startButton.addEventListener("click", () => {
              soundManager.init(),
                switchScreen(splashScreen, null, "playing"),
                startGameSequence();
            }),
              d
                .getElementById("resetProgressButton")
                .addEventListener("click", resetProgress),
              d
                .getElementById("unlockAllHatsButton")
                .addEventListener("click", unlockAllHats);
           }),
        setupEventListeners();
      }
      init();
    </script>
  </body>
</html>
